{"title":"JavaEE应用-Servlet","uid":"9116ce8cd7513e24b93bb0c7493010d2","slug":"JavaEE应用-Servlet","date":"2025-05-16T15:14:11.789Z","updated":"2025-05-16T18:15:44.705Z","comments":true,"path":"api/articles/JavaEE应用-Servlet.json","keywords":null,"cover":"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%23changli%20%23wutheringwaves%20%23wuwa.jpg","content":"<h1 id=\"JavaEE应用-Servlet\"><a href=\"#JavaEE应用-Servlet\" class=\"headerlink\" title=\"JavaEE应用-Servlet\"></a>JavaEE应用-Servlet</h1><h2 id=\"JavaEE-基础\"><a href=\"#JavaEE-基础\" class=\"headerlink\" title=\"JavaEE 基础\"></a>JavaEE 基础</h2><h3 id=\"一：Servlet-实现\"><a href=\"#一：Servlet-实现\" class=\"headerlink\" title=\"一：Servlet 实现\"></a>一：Servlet 实现</h3><p>继承抽象类 HttpServlet 的重写部分方法（常用）</p>\n<p>添加注解 @WebServlet(“&#x2F;LoginServlet”)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>servlet3.0 引入了 @WebServlet,@WebFilter 等注解，可以代替在 web.xml 中通过 <servlet><filter > 等标签进行配置 , 从而可以摆脱掉 web.xml，@WebServlet(“&#x2F;LoginServlet”)</p></blockquote>\n<p>创建 Indexservlet 的类<br>    package com.example.demo2;</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.ServletException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.annotation.WebServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletRequest;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletResponse;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">/**</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* servlet实现</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* 1，创建Class类</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* 2，继承HttpServlet类</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* 3，重写Service()方法(Service方法在Servelt类被访问时自动调用，作用：接受请求，响应结果)</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* 4，在Servlet中添加注解，设置资源对位访问路径，浏览器通过访问路径，访问到Servlet类</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*/</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">@WebServlet(&quot;/ser01&quot;) //添加注解，访问路径</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">public class Indexservlet extends HttpServlet &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    @Override</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;Hello,Indexservlet&quot;);  //输出在控制台</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //响应数据</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.getWriter().write(&quot;Hello,Index&quot;);  //输出到客户端</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">&#125;</span></span></code></pre></div><h3 id=\"二：Servlet-的工作流程与生命周期\"><a href=\"#二：Servlet-的工作流程与生命周期\" class=\"headerlink\" title=\"二：Servlet 的工作流程与生命周期\"></a>二：Servlet 的工作流程与生命周期</h3><p>Servlet 的生命周期可以分为四个阶段，即装载类及创建实例阶段、初始化阶段、服务阶段和实例销毁阶段。</p>\n<ul>\n<li>1、初始化阶段  调用 init () 方法</li>\n<li>2、响应客户请求阶段。调用 service () 方法，由 service () 方法根据提交的方式选择执行 doGet () 或者 doPost () 方法</li>\n<li>3、终止阶段　　调用 destroy () 方法</li>\n</ul>\n<p>工作流程：</p>\n<ul>\n<li>通过请求头获知浏览器访问的是哪个主机</li>\n<li>在通过请求行获取访问的是哪个 web 应用</li>\n<li>再通过请求行中的请求路径获知访问的是哪个资源</li>\n<li>通过获取的资源路径在配置中匹配到真实路径</li>\n<li>服务器会创建 servlet 对象，（如果第一次访问时，创建 - servlet 实例，并调用 init 方法进行初始化操作）</li>\n<li>调用 service（request，response）方法来处理请求和响应的操作</li>\n<li>调用 service 完毕后返回服务器 由服务器将 response 缓冲区的数据取出</li>\n</ul>\n<h3 id=\"三，HttpServleRequest-对象\"><a href=\"#三，HttpServleRequest-对象\" class=\"headerlink\" title=\"三，HttpServleRequest 对象\"></a>三，HttpServleRequest 对象</h3><p>作用：主要用来接受客户端发送过来的请求信息。例如：请求的参数，发送的头信息等都属于客户端发来的信息，service () 方法中的形参接受的是 HttpServletRequest 接口的实例化对象，表示对象主要运用在 HTTP 协议上，该对象有 Tomcat 封装好传递过来</p>\n<p><strong>接受请求：</strong></p>\n<p>常用方法：</p>\n<p>getRequestURL ()：获取客户端发出请求时的完整 URL</p>\n<p>getRequestURL ()：获取请求行中的资源名称部分（项目名称开始）</p>\n<p>getQueryString ()：获取请求行中的参数部分</p>\n<p>getMethod ()：获取客户端的请求方式</p>\n<p>getProtocol ()：获取 HTTP 版本号</p>\n<p>getContextPath ()：获取 webapp 名字（站点名）</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">        String url = req.getRequestURL().toString();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取客户端请求的完整URL &quot;+url);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取客户端请求的完整URL （从http 开始，到？前面结束）</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String uri = req.getRequestURI();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取客户端请求的完整URi &quot;+uri);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取请求中的参数部分</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String queryString=req.getQueryString();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取请求中的参数部分:&quot;+queryString);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取客户端的请求方式</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String method = req.getMethod();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取客户端的请求方式:&quot;+method);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取HTTP版本号</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String protocol=req.getProtocol();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取HTTP版本号:&quot;+protocol);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取webapp名字（站点名）</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String webapp =req.getContextPath();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;获取webapp名字（站点名）:&quot;+webapp);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">/**</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *获取请求参数</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *   1.通过参数名获取参数值， 返回字符串</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *   req.getParameter(&quot;参数名&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *      参数名：</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *         1.表达元素name属性值</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *         2.ajax的data属性值的键</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *         3.超链接参数的键</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *   2.通过参数名获取所有的参数值，返回数组</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        *</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        **   */</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //获取用户名</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String uname = req.getParameter(&quot;unmae&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String upwd = req.getParameter(&quot;upwd&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;姓名：&quot;+uname+&quot;密码&quot;+upwd);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //通过参数名获取所有的参数值，返回数组</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        String[] hobby =req.getParameterValues(&quot;hobby&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(hobby.length);</span></span></code></pre></div><p><strong>请求转发：</strong></p>\n<p>请求转发，是一种服务器的行为，当客户端请求达到后，服务器进行准发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务端在响应发送给客户端，从始至终只有一个请求发出。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">request.getRequestDispatcher(url).forward(request.response);</span></span></code></pre></div><p><strong>Request 作用域</strong></p>\n<p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务跳转有效</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">//设置域对象内容</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">request.setAttribute(String name,String value);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//获取域对象内容</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">request.getAttrbute(String name);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//删除域对象内容</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">request.removeAttrbute(String name);</span></span></code></pre></div><p>request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在请求转发的过程中可以通过 request 来传输 &#x2F; 共享数据</p>\n<p><strong>响应数据</strong><br>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。<br>有两种形式:<br>getWriter() 获取字符流 (只能响应回字符)<br>getOutputStream() 获取字节流 (能响应一切数据)</p>\n<p><strong>重定向</strong></p>\n<p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">resp.sendRedirect(&quot;url&quot;);</span></span></code></pre></div><p>请求转发与重定向的区别</p>\n<ul>\n<li><ol>\n<li>请求转发的地址栏不发生改变，重定向的地址会被改变</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>请求转发是服务端跳转，重定向是客户端跳转</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>请求转发是一次请求，重定向是两次请求</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>请求转发是 request 作用域可以共享，重定向是不可以共享</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>请求转发的地址是跳转到当前项目的资源，重定向可以跳转到任意资源</li>\n</ol>\n<p>  package com.example.demo2;</p>\n<p>  import javax.servlet.ServletException;<br>  import javax.servlet.annotation.WebServlet;<br>  import javax.servlet.http.HttpServlet;<br>  import javax.servlet.http.HttpServletRequest;<br>  import javax.servlet.http.HttpServletResponse;<br>  import java.io.IOException;</p>\n<p>  @WebServlet(“&#x2F;ser03”)<br>  public class servlet03 extends HttpServlet{<br>          @Override<br>          protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>              System.out.println(“yes…..”);</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">          String name = req.getParameter(&quot;name&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">          String pwd = req.getParameter(&quot;pwd&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">                  System.out.println(&quot;servlet...&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">                  //请求转发(服务端)</span></span></code></pre></div><p>  &#x2F;&#x2F;        req.getRequestDispatcher(“index.jsp”).forward(req,resp);</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">                  //重定向 跳转到首页（服务端）</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">                  resp.sendRedirect(&quot;http://www.baidu.com&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">                  //跳转到百度</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">      &#125;</span></span></code></pre></div><p>  }</p>\n</li>\n</ul>\n<p><strong>Cookie 对象</strong><br>通过 new Cookie (“key” “value”); 来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie (cookie); 此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见</p>\n<p><strong>cookie 获取</strong></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">Cookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        </span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//响应cookie对象</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">resp.addCookie(cookie);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">package com.shsxt.servlet.Cookie;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.ServletException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.annotation.WebServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.Cookie;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletRequest;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletResponse;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">/**</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* Cookie</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*     是浏览器技术</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* Cookie对象的创建与发送</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* */</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">@WebServlet(&quot;/cook01&quot;)</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">public class Cookie01 extends HttpServlet &#123;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    @Override</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //得到Cookie对象</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        Cookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //响应cookie对象</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.addCookie(cookie);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">&#125;</span></span></code></pre></div><p><img src=\"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-6.png\"></p>\n<p><strong>Cookie 的路径</strong></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        // 1.当前服务器下，任务项目的任意资源，都可获取Cookie对象</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        Cookie cookie01=new Cookie(&quot;aa&quot;,&quot;AA&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        cookie01.setPath(&quot;/&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.addCookie(cookie01);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//      2.在当前项目下，可以获取cookie对象（默认）</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        Cookie cookie02=new Cookie(&quot;bb&quot;,&quot;BB&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        cookie02.setPath(&quot;/zhongsheng&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.addCookie(cookie02);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//        3.在指定项目下，可获取cookie对象（指定项目站点名：/s05）</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        Cookie cookie03=new Cookie(&quot;cc&quot;,&quot;CC&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        cookie03.setPath(&quot;/ser05&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.addCookie(cookie03);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//        4.在指定项目的指定资源下，以获取cookie对象</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        Cookie cookie04=new Cookie(&quot;dd&quot;,&quot;DD&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        cookie04.setPath(&quot;/zhongsheng/test&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.addCookie(cookie04);</span></span></code></pre></div><p>Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。<br>*<br>当前项目：站点名为：&#x2F;zhongsheng<br>当前服务域名为：localhost:8080<br>设置路径：setpath (), 默认当前项目的站点名<br>setPath(“&#x2F;zhongsheng”)<br>*</p>\n<ul>\n<li><ol>\n<li>当前服务器下，任务项目的任意资源，都可获取 Cookie 对象</li>\n</ol>\n</li>\n<li>serpath(“&#x2F;”);</li>\n<li><ol start=\"2\">\n<li>在当前项目下，可以获取 cookie 对象（默认）</li>\n</ol>\n</li>\n<li>setPath（“&#x2F;zhongsheng”）</li>\n<li><ol start=\"3\">\n<li>在指定项目下，可获取 cookie 对象（指定项目站点名：&#x2F;s05）</li>\n</ol>\n</li>\n<li>setPath（“&#x2F;s05”）</li>\n<li><ol start=\"4\">\n<li>在指定项目的指定资源下，以获取 cookie 对象<br>setPath（“&#x2F;zhongsheng&#x2F;ser12”）;</li>\n</ol>\n</li>\n</ul>\n<p><strong>HttpSesion 对象</strong></p>\n<p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p>\n<p>session 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的 session，因为每一个 session 只保存在当前的浏览器当中，并在相关的页面取得。</p>\n<p>Session 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过 request.getSession () 方法，来获取当前会话的 session 对象。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">//创建获取Session</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">HttpSession session =req.getSession();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//设置sessiony</span></span></code></pre></div><p><strong>标识符 JSESSIONID</strong></p>\n<p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。</p>\n<p>每当一次请求到达服务器，如果开启了会话 (访问了 session)，服务器第一步会查看是否从客户端回传一个名为 JSESSIONID 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionld 为此次会话做一个标志。如果有 JESSIONID 这个 cookie 回传，服务器则会根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话；如果找到了相应的 session 对象，则认为是之前标志过的一次会话共享。</p>\n<p>这里提到一个叫做 JSESSIONID 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSIONID，值为获取到的 session (无论是获取到的还是新创建的) 的 sessionld 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p>\n<p>所以 Session 的底层依赖 Cookie 来实现。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki aurora-future\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #bbbbbb\">package com.shsxt.servlet.Session;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.ServletException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.annotation.WebServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServlet;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletRequest;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpServletResponse;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import javax.servlet.http.HttpSession;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">import java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">/**</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">* Session的作用域</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    再一次会话中有效</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    通过setAttribute(name , value)方法向域对象中添加数据</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    通过getAttribute(name)从域对象中获取数据</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    通过removeArribute（name）从域对象移除数据</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    request作用域</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*       知在一次请求有效</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*       只在请求转发跳转有效</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*    session作用域：</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*        在一次会话中有效，会话中包含多次请求</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*        在请求转发与重定向跳转后都有效</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">*        </span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">**/</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">@WebServlet(&quot;/ses02&quot;)</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">public class Session02 extends HttpServlet &#123;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    @Override</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //创建获取Session</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        HttpSession session =req.getSession();</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        System.out.println(&quot;session02&quot;+session.getId());</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //request作用域</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        req.setAttribute(&quot;requestMsg&quot;,&quot;request的作用域&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //session作用域</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        session.setAttribute(&quot;sessionMsg&quot;,&quot;session的作用域&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //请求转发</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        //重定向</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">        resp.sendRedirect(&quot;index.jsp&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\"></span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #bbbbbb\">&#125;</span></span></code></pre></div>","feature":true,"text":"JavaEE应用-ServletJavaEE 基础一：Servlet 实现继承抽象类 HttpServlet 的重写部分方法（常用） 添加注解 @WebServ...","permalink":"/post/JavaEE应用-Servlet","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"基础知识","slug":"基础知识","count":11,"path":"api/categories/基础知识.json"}],"tags":[{"name":"基础","slug":"基础","count":11,"path":"api/tags/基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaEE%E5%BA%94%E7%94%A8-Servlet\"><span class=\"toc-text\">JavaEE应用-Servlet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaEE-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">JavaEE 基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%EF%BC%9AServlet-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">一：Servlet 实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%EF%BC%9AServlet-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">二：Servlet 的工作流程与生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%EF%BC%8CHttpServleRequest-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">三，HttpServleRequest 对象</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hao","slug":"blog-author","avatar":"https://i.pinimg.com/736x/64/96/6b/64966b30e1c9375e8dbb11146ea9c12f.jpg","link":"/","description":"个人网络安全博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"抓包工具","uid":"debbc591069b02b5cd9e83564e08a4e5","slug":"抓包工具","date":"2025-05-16T15:10:32.952Z","updated":"2025-05-16T15:16:37.148Z","comments":true,"path":"api/articles/抓包工具.json","keywords":null,"cover":"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%23cartethyia%20%23wutheringwaves%20%23wuwa.jpg","text":"抓包工具BurpSuite 破解版 https://pan.baidu.com/s/1yUcTEeJVETKjsw3RQq76vw?pwd=smar 提取码: ...","permalink":"/post/抓包工具","photos":[],"count_time":{"symbolsCount":325,"symbolsTime":"1 mins."},"categories":[{"name":"基础知识","slug":"基础知识","count":11,"path":"api/categories/基础知识.json"}],"tags":[{"name":"基础","slug":"基础","count":11,"path":"api/tags/基础.json"}],"author":{"name":"Hao","slug":"blog-author","avatar":"https://i.pinimg.com/736x/64/96/6b/64966b30e1c9375e8dbb11146ea9c12f.jpg","link":"/","description":"个人网络安全博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}